<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>双指针(链表)</title>
      <link href="/2022/04/20/%E5%8F%8C%E6%8C%87%E9%92%88(%E9%93%BE%E8%A1%A8)/"/>
      <url>/2022/04/20/%E5%8F%8C%E6%8C%87%E9%92%88(%E9%93%BE%E8%A1%A8)/</url>
      
        <content type="html"><![CDATA[<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>无法高效获取长度，无法根据偏移快速访问元素，是链表的两个劣势。然而面试的时候经常碰见诸如<strong>获取倒数第k个元素，获取中间位置的元素，判断链表是否存在环，判断环的长度等和长度与位置有关的问题</strong>。这些问题都可以通过灵活运用<strong>双指针</strong>来解决。</p><p><code>**Tips：双指针并不是固定的公式，而是一种思维方式~**</code></p><p>先来看”倒数第k个元素的问题”。设有两个指针 p 和 q，初始时均指向头结点。首先，先让 p 沿着 next 移动 k 次。此时，p 指向第 k+1个结点，q 指向头节点，两个指针的距离为 k 。然后，同时移动 p 和 q，直到 p 指向空，此时 q 即指向倒数第 k 个结点。可以参考下图来理解：</p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/8fc9ef022554d2a062db6a70d5199dbbb2a154ba1e64f0f697319bb0ef9ac680.png" style="zoom:80%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">kNode</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(k != <span class="number">0</span> &amp;&amp; kNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            kNode = kNode.next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(kNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            kNode = kNode.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取中间元素的问题。设有两个指针 fast 和 slow，初始时指向头节点。每次移动时，fast向后走两次，slow向后走一次，直到 fast 无法向后走两次。这使得在每轮移动之后，<strong>fast 和 slow 的距离就会增加一</strong>。设链表有 n 个元素，那么最多移动 n&#x2F;2 轮。<strong>当 n 为奇数时，slow 恰好指向中间结点，当 n 为 偶数时，slow 恰好指向中间两个结点的靠前一个</strong>(可以考虑下<strong>如何使其指向后一个结点呢？</strong>)。</p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/7984572cea859a3d569932934fe6580abf3f59221ec95911f662f1f19b6822aa.png" style="zoom:80%;" /><p>下述代码实现了 n 为<strong>偶数</strong>时慢指针指向<strong>靠后结点</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *p = head, *q = head;</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="literal">nullptr</span> &amp;&amp; q-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>是否存在环的问题。如果将尾结点的 next 指针指向其他任意一个结点，那么链表就存在了一个环。</p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/ea4aff71116d6c483b2b34519497d39d640435cb3ce12ea1b40dd453c45b59fd.png" style="zoom:80%;" /><p>上一部分中，总结快慢指针的特性 —— 每轮移动之后两者的距离会加一。下面会继续用该特性解决环的问题。<br>当一个链表有环时，快慢指针都会陷入环中进行无限次移动，然后变成了追及问题。想象一下在操场跑步的场景，只要一直跑下去，快的总会追上慢的。当两个指针都进入环后，每轮移动使得慢指针到快指针的距离增加一，同时快指针到慢指针的距离也减少一，只要一直移动下去，快指针总会追上慢指针。</p><p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/d1ac82780e5189d7d58406504c3b7b56c35165997bfbb4c325677af92ee2d483.gif"></p><p>根据上述表述得出，如果一个链表存在环，那么快慢指针必然会相遇。实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一个问题，如果存在环，如何判断环的长度呢？方法是，<code>**快慢指针相遇后继续移动，直到第二次相遇。两次相遇间的移动次数即为环的长度。**</code></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构预算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2022/04/19/Redis/"/>
      <url>/2022/04/19/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="1-NoSQL的引言"><a href="#1-NoSQL的引言" class="headerlink" title="1.  NoSQL的引言"></a>1.  NoSQL的引言</h2><p><strong>NoSQL</strong>(<code> Not Only SQL</code> )，意即<strong>不仅仅是SQL</strong>, 泛指非关系型的数据库。Nosql这个技术门类,早期就有人提出,发展至2009年趋势越发高涨。</p><h2 id="2-为什么是NoSQL"><a href="#2-为什么是NoSQL" class="headerlink" title="2. 为什么是NoSQL"></a>2. 为什么是NoSQL</h2><p>随着互联网网站的兴起，传统的关系数据库在应付动态网站，特别是超大规模和高并发的纯动态网站已经显得力不从心，暴露了很多难以克服的问题。如<code>商城网站中对商品数据频繁查询</code>、<code>对热搜商品的排行统计</code>、<code>订单超时问题</code>、以及微信朋友圈（音频，视频）存储等相关使用传统的关系型数据库实现就显得非常复杂，虽然能实现相应功能但是在性能上却不是那么乐观。nosql这个技术门类的出现，更好的解决了这些问题，它告诉了世界不仅仅是sql。</p><h2 id="3-NoSQL的四大分类"><a href="#3-NoSQL的四大分类" class="headerlink" title="3. NoSQL的四大分类"></a>3. NoSQL的四大分类</h2><h3 id="3-1-键值-Key-Value-存储数据库"><a href="#3-1-键值-Key-Value-存储数据库" class="headerlink" title="3.1 键值(Key-Value)存储数据库"></a>3.1 键值(Key-Value)存储数据库</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.说明: </span></span><br><span class="line"><span class="bullet">-</span> 这一类数据库主要会使用到一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据。</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.特点</span></span><br><span class="line"><span class="bullet">-</span> Key/value模型对于IT系统来说的优势在于简单、易部署。  </span><br><span class="line"><span class="bullet">-</span> 但是如果DBA只对部分值进行查询或更新的时候，Key/value就显得效率低下了。</span><br><span class="line"></span><br><span class="line"><span class="section"># 3.相关产品</span></span><br><span class="line"><span class="bullet">-</span> Tokyo Cabinet/Tyrant,</span><br><span class="line"><span class="bullet">-</span> Redis</span><br><span class="line"><span class="bullet">-</span> SSDB</span><br><span class="line"><span class="bullet">-</span> Voldemort </span><br><span class="line"><span class="bullet">-</span> Oracle BDB</span><br></pre></td></tr></table></figure><h3 id="3-2-列存储数据库"><a href="#3-2-列存储数据库" class="headerlink" title="3.2 列存储数据库"></a>3.2 列存储数据库</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.说明</span></span><br><span class="line"><span class="bullet">-</span> 这部分数据库通常是用来应对分布式存储的海量数据。</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.特点</span></span><br><span class="line"><span class="bullet">-</span> 键仍然存在，但是它们的特点是指向了多个列。这些列是由列家族来安排的。</span><br><span class="line"></span><br><span class="line"><span class="section"># 3.相关产品</span></span><br><span class="line"><span class="bullet">-</span> Cassandra、HBase、Riak.</span><br></pre></td></tr></table></figure><h3 id="3-3-文档型数据库"><a href="#3-3-文档型数据库" class="headerlink" title="3.3 文档型数据库"></a>3.3 文档型数据库</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.说明</span></span><br><span class="line"><span class="bullet">-</span> 文档型数据库的灵感是来自于Lotus Notes办公软件的，而且它同第一种键值存储相类似该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可 以看作是键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.特点</span></span><br><span class="line"><span class="bullet">-</span> 以文档形式存储</span><br><span class="line"></span><br><span class="line"><span class="section"># 3.相关产品</span></span><br><span class="line"><span class="bullet">-</span> MongoDB、CouchDB、 MongoDb(4.x). 国内也有文档型数据库SequoiaDB，已经开源。</span><br></pre></td></tr></table></figure><h3 id="3-4-图形-Graph-数据库"><a href="#3-4-图形-Graph-数据库" class="headerlink" title="3.4 图形(Graph)数据库"></a>3.4 图形(Graph)数据库</h3> <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.说明</span></span><br><span class="line"><span class="bullet">-</span> 图形结构的数据库同其他行列以及刚性结构的SQL数据库不同，它是使用灵活的图形模型，并且能够扩展到多个服务器上。</span><br><span class="line"><span class="bullet">-</span> NoSQL数据库没有标准的查询语言(SQL)，因此进行数据库查询需要制定数据模型。许多NoSQL数据库都有REST式的数据接口或者查询API。</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.特点</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 3.相关产品</span></span><br><span class="line"><span class="bullet">-</span> Neo4J、InfoGrid、 Infinite Graph、</span><br></pre></td></tr></table></figure><hr><h2 id="4-NoSQL应用场景"><a href="#4-NoSQL应用场景" class="headerlink" title="4. NoSQL应用场景"></a>4. NoSQL应用场景</h2><ul><li><p>数据模型比较简单</p></li><li><p>需要灵活性更强的IT系统</p></li><li><p>对数据库性能要求较高</p></li><li><p>不需要高度的数据一致性</p></li></ul><h2 id="5-什么是Redis"><a href="#5-什么是Redis" class="headerlink" title="5. 什么是Redis"></a>5. 什么是Redis</h2><p><img src="D:\Typora\img\image-20220420141519994.png" alt="image-20220420141519994"></p><blockquote><p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker.</p></blockquote><p>Redis 开源  遵循BSD  基于内存数据存储 被用于作为 数据库 缓存  消息中间件</p><ul><li>总结: redis是一个内存型的数据库</li></ul><h2 id="6-Redis特点"><a href="#6-Redis特点" class="headerlink" title="6. Redis特点"></a>6. Redis特点</h2><ul><li><p>Redis是一个高性能key&#x2F;value内存型数据库</p></li><li><p>Redis支持丰富的数据类型 </p></li><li><p>Redis支持持久化 </p></li><li><p>Redis单线程,单进程</p></li></ul><hr><h2 id="7-Redis安装"><a href="#7-Redis安装" class="headerlink" title="7. Redis安装"></a>7. Redis安装</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 0.准备环境</span></span><br><span class="line"><span class="bullet">-</span> vmware15.x+</span><br><span class="line"><span class="bullet">-</span> centos7.x+</span><br><span class="line"></span><br><span class="line"><span class="section"># 1.下载redis源码包</span></span><br><span class="line"><span class="bullet">-</span> https://redis.io/</span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200623121621195.png" alt="image-20200623121621195"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 2.下载完整源码包</span></span><br><span class="line"><span class="bullet">-</span> redis-4.0.10.tar.gz</span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200623123918876.png" alt="image-20200623123918876"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 3.将下载redis资料包上传到Linux中</span></span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200623124327319.png" alt="image-20200623124327319"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 4.解压缩文件</span></span><br><span class="line">[root@localhost ~]# tar -zxvf redis-4.0.10.tar.gz</span><br><span class="line">[root@localhost ~]# ll</span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200623124522026.png" alt="image-20200623124522026"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 5.安装gcc  </span></span><br><span class="line"><span class="bullet">-</span> yum install -y gcc</span><br><span class="line"></span><br><span class="line"><span class="section"># 6.进入解压缩目录执行如下命令</span></span><br><span class="line"><span class="bullet">-</span> make MALLOC=libc</span><br><span class="line"></span><br><span class="line"><span class="section"># 7.编译完成后执行如下命令</span></span><br><span class="line"><span class="bullet">-</span> make install PREFIX=/usr/redis</span><br><span class="line"></span><br><span class="line"><span class="section"># 8.进入/usr/redis目录启动redis服务 </span></span><br><span class="line"><span class="bullet">-</span> ./redis-server</span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200623125420505.png" alt="image-20200623125420505"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 9.Redis服务端口默认是 6379</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 10.进入bin目录执行客户端连接操作</span></span><br><span class="line"><span class="bullet">-</span> ./redis-cli –p 6379</span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200623125716013.png" alt="image-20200623125716013"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 11.连接成功出现上面界面连接成功</span></span><br></pre></td></tr></table></figure><h2 id="8-Redis数据库相关指令"><a href="#8-Redis数据库相关指令" class="headerlink" title="8. Redis数据库相关指令"></a>8. Redis数据库相关指令</h2><h3 id="8-1-数据库操作指令"><a href="#8-1-数据库操作指令" class="headerlink" title="8.1 数据库操作指令"></a>8.1 数据库操作指令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.Redis中库说明</span></span><br><span class="line"><span class="bullet">-</span> 使用redis的默认配置器动redis服务后,默认会存在16个库,编号从0-15</span><br><span class="line"><span class="bullet">-</span> 可以使用select 库的编号 来选择一个redis的库</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.Redis中操作库的指令</span></span><br><span class="line"><span class="bullet">-</span> 清空当前的库  FLUSHDB</span><br><span class="line"><span class="bullet">-</span> 清空全部的库  FLUSHALL</span><br><span class="line"></span><br><span class="line"><span class="section"># 3.redis客户端显示中文</span></span><br><span class="line"><span class="bullet">-</span>./redis-cli  -p 7000 --raw</span><br></pre></td></tr></table></figure><h3 id="8-2-操作key相关指令"><a href="#8-2-操作key相关指令" class="headerlink" title="8.2 操作key相关指令"></a>8.2 操作key相关指令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.DEL指令</span></span><br><span class="line"><span class="bullet">-</span> 语法 :  DEL key [key ...] </span><br><span class="line"><span class="bullet">-</span> 作用 :  删除给定的一个或多个key 。不存在的key 会被忽略。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 1.0.0</span><br><span class="line"><span class="bullet">-</span> 返回值： 被删除key 的数量。 </span><br><span class="line"></span><br><span class="line"><span class="section"># 2.EXISTS指令</span></span><br><span class="line"><span class="bullet">-</span> 语法:  EXISTS key</span><br><span class="line"><span class="bullet">-</span> 作用:  检查给定key 是否存在。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 1.0.0</span><br><span class="line"><span class="bullet">-</span> 返回值： 若key 存在，返回1 ，否则返回0。</span><br><span class="line"></span><br><span class="line"><span class="section"># 3.EXPIRE</span></span><br><span class="line"><span class="bullet">-</span> 语法:  EXPIRE key seconds</span><br><span class="line"><span class="bullet">-</span> 作用:  为给定key 设置生存时间，当key 过期时(生存时间为0 )，它会被自动删除。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 1.0.0</span><br><span class="line"><span class="bullet">-</span> 时间复杂度： O(1)</span><br><span class="line"><span class="bullet">-</span> 返回值：设置成功返回1 。</span><br><span class="line"></span><br><span class="line"><span class="section"># 4.KEYS</span></span><br><span class="line"><span class="bullet">-</span> 语法 :  KEYS pattern</span><br><span class="line"><span class="bullet">-</span> 作用 :  查找所有符合给定模式pattern 的key 。</span><br><span class="line"><span class="bullet">-</span> 语法:</span><br><span class="line"><span class="code">KEYS * 匹配数据库中所有key 。</span></span><br><span class="line"><span class="code">KEYS h?llo 匹配hello ，hallo 和hxllo 等。</span></span><br><span class="line"><span class="code">KEYS h*llo 匹配hllo 和heeeeello 等。</span></span><br><span class="line"><span class="code">KEYS h[ae]llo 匹配hello 和hallo ，但不匹配hillo 。特殊符号用 &quot;\&quot; 隔开</span></span><br><span class="line"><span class="code">- 可用版本： &gt;= 1.0.0</span></span><br><span class="line"><span class="code">- 返回值： 符合给定模式的key 列表。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 5.MOVE</span></span><br><span class="line"><span class="bullet">-</span> 语法 :  MOVE key db</span><br><span class="line"><span class="bullet">-</span> 作用 :  将当前数据库的key 移动到给定的数据库db 当中。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 1.0.0</span><br><span class="line"><span class="bullet">-</span> 返回值： 移动成功返回1 ，失败则返回0 。</span><br><span class="line"></span><br><span class="line"><span class="section"># 6.PEXPIRE</span></span><br><span class="line"><span class="bullet">-</span> 语法 :  PEXPIRE key milliseconds</span><br><span class="line"><span class="bullet">-</span> 作用 :  这个命令和EXPIRE 命令的作用类似，但是它以毫秒为单位设置key 的生存时间，而不像EXPIRE 命令那样，以秒为单位。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 2.6.0</span><br><span class="line"><span class="bullet">-</span> 时间复杂度： O(1)</span><br><span class="line"><span class="bullet">-</span> 返回值：设置成功，返回1  key不存在或设置失败，返回0</span><br><span class="line"></span><br><span class="line"><span class="section"># 7.PEXPIREAT</span></span><br><span class="line"><span class="bullet">-</span> 语法 :  PEXPIREAT key milliseconds-timestamp</span><br><span class="line"><span class="bullet">-</span> 作用 :  这个命令和EXPIREAT 命令类似，但它以毫秒为单位设置key 的过期unix 时间戳，而不是像EXPIREAT那样，以秒为单位。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 2.6.0</span><br><span class="line"><span class="bullet">-</span> 返回值：如果生存时间设置成功，返回1 。当key 不存在或没办法设置生存时间时，返回0 。(查看EXPIRE 命令获取更多信息)</span><br><span class="line"></span><br><span class="line"><span class="section"># 8.TTL</span></span><br><span class="line"><span class="bullet">-</span> 语法 :   TTL key</span><br><span class="line"><span class="bullet">-</span> 作用 :   以秒为单位，返回给定key 的剩余生存时间(TTL, time to live)。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 1.0.0</span><br><span class="line"><span class="bullet">-</span> 返回值：</span><br><span class="line"><span class="code">当key 不存在时，返回-2 。</span></span><br><span class="line"><span class="code">当key 存在但没有设置剩余生存时间时，返回-1 。</span></span><br><span class="line"><span class="code">否则，以秒为单位，返回key 的剩余生存时间。</span></span><br><span class="line"><span class="code">- Note : 在Redis 2.8 以前，当key 不存在，或者key 没有设置剩余生存时间时，命令都返回-1 。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 9.PTTL</span></span><br><span class="line"><span class="bullet">-</span> 语法 :  PTTL key</span><br><span class="line"><span class="bullet">-</span> 作用 :  这个命令类似于TTL 命令，但它以毫秒为单位返回key 的剩余生存时间，而不是像TTL 命令那样，以秒为单位。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 2.6.0</span><br><span class="line"><span class="bullet">-</span> 返回值： 当key 不存在时，返回-2 。当key 存在但没有设置剩余生存时间时，返回-1 。</span><br><span class="line"><span class="bullet">-</span> 否则，以毫秒为单位，返回key 的剩余生存时间。</span><br><span class="line"><span class="bullet">-</span> 注意 : 在Redis 2.8 以前，当key 不存在，或者key 没有设置剩余生存时间时，命令都返回-1 。</span><br><span class="line"></span><br><span class="line"><span class="section"># 10.RANDOMKEY</span></span><br><span class="line"><span class="bullet">-</span> 语法 :  RANDOMKEY</span><br><span class="line"><span class="bullet">-</span> 作用 :  从当前数据库中随机返回(不删除) 一个key 。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 1.0.0</span><br><span class="line"><span class="bullet">-</span> 返回值：当数据库不为空时，返回一个key 。当数据库为空时，返回nil 。</span><br><span class="line"></span><br><span class="line"><span class="section"># 11.RENAME</span></span><br><span class="line"><span class="bullet">-</span> 语法 :  RENAME key newkey</span><br><span class="line"><span class="bullet">-</span> 作用 :  将key 改名为newkey 。当key 和newkey 相同，或者key 不存在时，返回一个错误。当newkey 已经存在时，RENAME 命令将覆盖旧值。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 1.0.0</span><br><span class="line"><span class="bullet">-</span> 返回值： 改名成功时提示OK ，失败时候返回一个错误。</span><br><span class="line"></span><br><span class="line"><span class="section"># 12.TYPE</span></span><br><span class="line"><span class="bullet">-</span> 语法 :  TYPE key</span><br><span class="line"><span class="bullet">-</span> 作用 :  返回key 所储存的值的类型。</span><br><span class="line"><span class="bullet">-</span> 可用版本： &gt;= 1.0.0</span><br><span class="line"><span class="bullet">-</span> 返回值：</span><br><span class="line"><span class="code">none (key 不存在)</span></span><br><span class="line"><span class="code">string (字符串)</span></span><br><span class="line"><span class="code">list (列表)</span></span><br><span class="line"><span class="code">set (集合)</span></span><br><span class="line"><span class="code">zset (有序集)</span></span><br><span class="line"><span class="code">hash (哈希表)</span></span><br></pre></td></tr></table></figure><h3 id="8-3-String类型"><a href="#8-3-String类型" class="headerlink" title="8.3 String类型"></a>8.3 String类型</h3><h4 id="1-内存存储模型"><a href="#1-内存存储模型" class="headerlink" title="1. 内存存储模型"></a>1. 内存存储模型</h4><p><img src="/../Typora/img/image-20200623132104399.png" alt="image-20200623132104399"></p><h4 id="2-常用操作命令"><a href="#2-常用操作命令" class="headerlink" title="2. 常用操作命令"></a>2. 常用操作命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>set</td><td>设置一个key&#x2F;value</td></tr><tr><td>get</td><td>根据key获得对应的value</td></tr><tr><td>mset</td><td>一次设置多个key value</td></tr><tr><td>mget</td><td>一次获得多个key的value</td></tr><tr><td>getset</td><td>获得原始key的值，同时设置新值</td></tr><tr><td>strlen</td><td>获得对应key存储value的长度</td></tr><tr><td>append</td><td>为对应key的value追加内容</td></tr><tr><td>getrange 索引0开始</td><td>截取value的内容[左闭右闭]</td></tr><tr><td>setex</td><td>设置一个key存活的有效期（秒）</td></tr><tr><td>psetex</td><td>设置一个key存活的有效期（毫秒）</td></tr><tr><td>setnx</td><td>存在不做任何操作,不存在添加</td></tr><tr><td>msetnx原子操作(只要有一个存在不做任何操作)</td><td>可以同时设置多个key,只有有一个存在都不保存</td></tr><tr><td>decr</td><td>进行数值类型的-1操作</td></tr><tr><td>decrby</td><td>根据提供的数据进行减法操作</td></tr><tr><td>Incr</td><td>进行数值类型的+1操作</td></tr><tr><td>incrby</td><td>根据提供的数据进行加法操作</td></tr><tr><td>Incrbyfloat</td><td>根据提供的数据加入浮点数</td></tr></tbody></table><h3 id="8-4-List类型"><a href="#8-4-List类型" class="headerlink" title="8.4 List类型"></a>8.4 List类型</h3><p>list 列表 相当于java中list 集合  特点  元素有序  且 可以重复</p><h4 id="1-内存存储模型-1"><a href="#1-内存存储模型-1" class="headerlink" title="1.内存存储模型"></a>1.内存存储模型</h4><p><img src="/../Typora/img/image-20200623161114380.png" alt="image-20200623161114380"></p><h4 id="2-常用操作指令"><a href="#2-常用操作指令" class="headerlink" title="2.常用操作指令"></a>2.常用操作指令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>lpush</td><td>将某个值加入到一个key列表头部</td></tr><tr><td>lpushx</td><td>同lpush,但是必须要保证这个key存在</td></tr><tr><td>rpush</td><td>将某个值加入到一个key列表末尾</td></tr><tr><td>rpushx</td><td>同rpush,但是必须要保证这个key存在</td></tr><tr><td>lpop</td><td>返回和移除列表左边的第一个元素</td></tr><tr><td>rpop</td><td>返回和移除列表右边的第一个元素</td></tr><tr><td>lrange</td><td>获取某一个下标区间内的元素</td></tr><tr><td>llen</td><td>获取列表元素个数</td></tr><tr><td>lset</td><td>设置某一个指定索引的值(索引必须存在)</td></tr><tr><td>lindex</td><td>获取某一个指定索引位置的元素</td></tr><tr><td>lrem</td><td>删除重复元素，后面加上要删除重复元素的数量</td></tr><tr><td>ltrim</td><td>保留列表中特定区间内的元素</td></tr><tr><td>linsert</td><td>在某一个元素之前，之后插入新元素（默认从左至右插入）</td></tr></tbody></table><h3 id="8-5-Set类型"><a href="#8-5-Set类型" class="headerlink" title="8.5 Set类型"></a>8.5 Set类型</h3><p>特点: Set类型 Set集合 元素无序  不可以重复</p><h4 id="1-内存存储模型-2"><a href="#1-内存存储模型-2" class="headerlink" title="1.内存存储模型"></a>1.内存存储模型</h4><p><img src="/../Typora/img/image-20200623193634316.png" alt="image-20200623193634316"></p><h4 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令"></a>2.常用命令</h4><table><thead><tr><th align="left">命令</th><th>说明</th></tr></thead><tbody><tr><td align="left">sadd</td><td>为集合添加元素</td></tr><tr><td align="left">smembers</td><td>显示集合中所有元素 无序</td></tr><tr><td align="left">scard</td><td>返回集合中元素的个数</td></tr><tr><td align="left">spop</td><td>随机返回一个元素 并将元素在集合中删除</td></tr><tr><td align="left">smove</td><td>从一个集合中向另一个集合移动元素 （必须是同一种类型）</td></tr><tr><td align="left">srem</td><td>从集合中删除一个元素</td></tr><tr><td align="left">sismember</td><td>判断一个集合中是否含有这个元素</td></tr><tr><td align="left">srandmember</td><td>随机返回元素</td></tr><tr><td align="left">sdiff</td><td>去掉<strong>第一个集合</strong>中其它集合含有的相同元素</td></tr><tr><td align="left">sinter</td><td>求交集</td></tr><tr><td align="left">sunion</td><td>求和集</td></tr></tbody></table><h3 id="8-6-ZSet类型"><a href="#8-6-ZSet类型" class="headerlink" title="8.6 ZSet类型"></a>8.6 ZSet类型</h3><p>特点: 可排序的set集合  排序  不可重复 </p><p>官方：ZSET    可排序SET： sortSet   </p><p>例子：zadd zsets 10 zhangsan….</p><h4 id="1-内存模型"><a href="#1-内存模型" class="headerlink" title="1.内存模型"></a>1.内存模型</h4><p><img src="/../Typora/img/image-20200623194903967.png" alt="image-20200623194903967"></p><h4 id="2-常用命令-1"><a href="#2-常用命令-1" class="headerlink" title="2.常用命令"></a>2.常用命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>zadd</td><td>添加一个有序集合元素</td></tr><tr><td>zcard</td><td>返回集合的元素个数</td></tr><tr><td>zrange 升序 zrevrange 降序</td><td>返回一个范围内的元素</td></tr><tr><td>zrangebyscore</td><td>按照分数查找一个范围内的元素</td></tr><tr><td>zrank</td><td>返回排名</td></tr><tr><td>zrevrank</td><td>倒序排名</td></tr><tr><td>zscore</td><td>显示某一个元素的分数</td></tr><tr><td>zrem</td><td>移除某一个元素</td></tr><tr><td>zincrby</td><td>给某个特定元素加分</td></tr></tbody></table><h3 id="8-7-hash类型"><a href="#8-7-hash类型" class="headerlink" title="8.7 hash类型"></a>8.7 hash类型</h3><p>特点: value 是一个map结构 存在key value  key 无序的  </p><h4 id="1-内存模型-1"><a href="#1-内存模型-1" class="headerlink" title="1.内存模型"></a>1.内存模型</h4><p><img src="/../Typora/img/image-20200623200348408.png" alt="image-20200623200348408"></p><h4 id="2-常用命令-2"><a href="#2-常用命令-2" class="headerlink" title="2.常用命令"></a>2.常用命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>hset</td><td>设置一个key&#x2F;value对</td></tr><tr><td>hget</td><td>获得一个key对应的value</td></tr><tr><td>hgetall</td><td>获得所有的key&#x2F;value对</td></tr><tr><td>hdel</td><td>删除某一个key&#x2F;value对</td></tr><tr><td>hexists</td><td>判断一个key是否存在</td></tr><tr><td>hkeys</td><td>获得所有的key</td></tr><tr><td>hvals</td><td>获得所有的value</td></tr><tr><td>hmset</td><td>设置多个key&#x2F;value</td></tr><tr><td>hmget</td><td>获得多个key的value</td></tr><tr><td>hsetnx</td><td>设置一个不存在的key的值</td></tr><tr><td>hincrby</td><td>为value进行加法运算</td></tr><tr><td>hincrbyfloat</td><td>为value加入浮点值</td></tr></tbody></table><hr><p><strong><code>可以找一个redis的可视化图形工具，方便去操作管理</code></strong></p><p><strong><code>具体的指令介绍和使用可以在B站学习资料中获取</code></strong></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="9-持久化机制"><a href="#9-持久化机制" class="headerlink" title="9. 持久化机制"></a>9. 持久化机制</h2><p>client  redis[内存] —–&gt;  内存数据- 数据持久化–&gt;磁盘</p><p>Redis官方提供了两种不同的持久化方法来将数据存储到硬盘里面分别是:</p><ul><li>快照(Snapshot)</li><li>AOF (Append Only File) 只追加日志文件</li></ul><h3 id="9-1-快照-Snapshot"><a href="#9-1-快照-Snapshot" class="headerlink" title="9.1 快照(Snapshot)"></a>9.1 快照(Snapshot)</h3><h4 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h4><p>这种方式可以将某一时刻的所有数据都写入硬盘中,当然这也是<strong>redis的默认开启持久化方式</strong>,保存的文件是以.rdb形式结尾的文件因此这种方式也称之为RDB方式。</p><p><img src="/../Typora/img/image-20200623204303074.png" alt="image-20200623204303074"></p><h4 id="2-快照生成方式"><a href="#2-快照生成方式" class="headerlink" title="2.快照生成方式"></a>2.快照生成方式</h4><ul><li>客户端方式: BGSAVE 和 SAVE指令</li><li>服务器配置自动触发</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.客户端方式之BGSAVE</span></span><br><span class="line"><span class="bullet">-</span> a.客户端可以使用BGSAVE命令来创建一个快照,当接收到客户端的BGSAVE命令时,redis会调用fork¹来创建一个子进程,然后子进程负责将快照写入磁盘中,而父进程则继续处理命令请求。</span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">`名词解释: fork当一个进程创建子进程的时候,底层的操作系统会创建该进程的一个副本,在类unix系统中创建子进程的操作会进行优化:在刚开始的时候,父子进程共享相同内存,直到父进程或子进程对内存进行了写之后,对被写入的内存的共享才会结束服务`</span></span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200623205132460.png" alt="image-20200623205132460"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 2.客户端方式之SAVE</span></span><br><span class="line"><span class="bullet">-</span> b.客户端还可以使用SAVE命令来创建一个快照,接收到SAVE命令的redis服务器在快照创建完毕之前将不再响应任何其他的命令</span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200623205444101.png" alt="image-20200623205444101"></p><ul><li><strong>注意: SAVE命令并不常用,使用SAVE命令在快照创建完毕之前,redis处于阻塞状态,无法对外服务</strong></li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 3.服务器配置方式之满足配置自动触发</span></span><br><span class="line"><span class="bullet">-</span> 如果用户在redis.conf中设置了save配置选项,redis会在save选项条件满足之后自动触发一次BGSAVE命令,如果设置多个save配置选项,当任意一个save配置选项条件满足,redis也会触发一次BGSAVE命令</span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200623210021012.png" alt="image-20200623210021012"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 4.服务器接收客户端shutdown指令</span></span><br><span class="line"><span class="bullet">-</span> 当redis通过shutdown指令接收到关闭服务器的请求时,会执行一个save命令,阻塞所有的客户端,不再执行客户端执行发送的任何命令,并且在save命令执行完毕之后关闭服务器</span><br></pre></td></tr></table></figure><h4 id="3-配置生成快照名称和位置"><a href="#3-配置生成快照名称和位置" class="headerlink" title="3.配置生成快照名称和位置"></a>3.配置生成快照名称和位置</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#1.修改生成快照名称</span></span><br><span class="line"><span class="bullet">-</span> dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.修改生成位置</span></span><br><span class="line"><span class="bullet">-</span> dir ./</span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200623210352448.png" alt="image-20200623210352448"></p><hr><h3 id="9-2-AOF-只追加日志文件"><a href="#9-2-AOF-只追加日志文件" class="headerlink" title="9.2 AOF 只追加日志文件"></a>9.2 AOF 只追加日志文件</h3><h4 id="1-特点-1"><a href="#1-特点-1" class="headerlink" title="1.特点"></a>1.特点</h4><p>这种方式可以将所有客户端执行的写命令记录到日志文件中,AOF持久化会将被执行的写命令写到AOF的文件末尾,以此来记录数据发生的变化,因此只要redis从头到尾执行一次AOF文件所包含的所有写命令,就可以恢复AOF文件的记录的数据集.</p><p><img src="/../Typora/img/image-20200623211330798.png" alt="image-20200623211330798"></p><h4 id="2-开启AOF持久化"><a href="#2-开启AOF持久化" class="headerlink" title="2.开启AOF持久化"></a>2.开启AOF持久化</h4><p>在redis的默认配置中AOF持久化机制是没有开启的，需要在配置中开启</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.开启AOF持久化</span></span><br><span class="line"><span class="bullet">-</span> a.修改 appendonly yes 开启持久化</span><br><span class="line"><span class="bullet">-</span> b.修改 appendfilename &quot;appendonly.aof&quot; 指定生成文件名称</span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200623211508987.png" alt="image-20200623211508987"></p><h4 id="3-日志追加频率"><a href="#3-日志追加频率" class="headerlink" title="3.日志追加频率"></a>3.日志追加频率</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.always 【谨慎使用】</span></span><br><span class="line"><span class="bullet">-</span> 说明: 每个redis写命令都要同步写入硬盘,严重降低redis速度</span><br><span class="line"><span class="bullet">-</span> 解释: 如果用户使用了always选项,那么每个redis写命令都会被写入硬盘,从而将发生系统崩溃时出现的数据丢失减到最少;遗憾的是,因为这种同步策略需要对硬盘进行大量的写入操作,所以redis处理命令的速度会受到硬盘性能的限制;</span><br><span class="line"><span class="bullet">-</span> 注意: 转盘式硬盘在这种频率下200左右个命令/s ; 固态硬盘(SSD) 几百万个命令/s;</span><br><span class="line"><span class="bullet">-</span> 警告: 使用SSD用户请谨慎使用always选项,这种模式不断写入少量数据的做法有可能会引发严重的写入放大问题,导致将固态硬盘的寿命从原来的几年降低为几个月。</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.everysec 【推荐】</span></span><br><span class="line"><span class="bullet">-</span> 说明: 每秒执行一次同步显式的将多个写命令同步到磁盘</span><br><span class="line"><span class="bullet">-</span> 解释： 为了兼顾数据安全和写入性能,用户可以考虑使用everysec选项,让redis每秒一次的频率对AOF文件进行同步;redis每秒同步一次AOF文件时性能和不使用任何持久化特性时的性能相差无几,而通过每秒同步一次AOF文件,redis可以保证,即使系统崩溃,用户最多丢失一秒之内产生的数据。</span><br><span class="line"></span><br><span class="line"><span class="section"># 3.no【不推荐】</span></span><br><span class="line"><span class="bullet">-</span> 说明: 由操作系统决定何时同步 </span><br><span class="line"><span class="bullet">-</span> 解释：最后使用no选项,将完全有操作系统决定什么时候同步AOF日志文件,这个选项不会对redis性能带来影响但是系统崩溃时,会丢失不定数量的数据,另外如果用户硬盘处理写入操作不够快的话,当缓冲区被等待写入硬盘数据填满时,redis会处于阻塞状态,并导致redis的处理命令请求的速度变慢。</span><br></pre></td></tr></table></figure><h4 id="4-修改同步频率"><a href="#4-修改同步频率" class="headerlink" title="4.修改同步频率"></a>4.修改同步频率</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.修改日志同步频率</span></span><br><span class="line"><span class="bullet">-</span> 修改appendfsync everysec|always|no 指定</span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200623211658910.png" alt="image-20200623211658910"></p><hr><h3 id="9-3-AOF文件的重写"><a href="#9-3-AOF文件的重写" class="headerlink" title="9.3 AOF文件的重写"></a>9.3 AOF文件的重写</h3><h4 id="1-AOF带来的问题"><a href="#1-AOF带来的问题" class="headerlink" title="1. AOF带来的问题"></a>1. AOF带来的问题</h4><p>AOF的方式也同时带来了另一个问题。持久化文件会变的越来越大。例如我们调用incr test命令100次，文件中必须保存全部的100条命令，其实有99条都是多余的。因为要恢复数据库的状态其实文件中保存一条set test 100就够了。为了压缩aof的持久化文件Redis提供了AOF重写(ReWriter)机制。</p><h4 id="2-AOF重写"><a href="#2-AOF重写" class="headerlink" title="2. AOF重写"></a>2. AOF重写</h4><p>用来在一定程度上减小AOF文件的体积</p><h4 id="3-触发重写方式"><a href="#3-触发重写方式" class="headerlink" title="3. 触发重写方式"></a>3. 触发重写方式</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.客户端方式触发重写</span></span><br><span class="line"><span class="bullet">-</span> 执行BGREWRITEAOF命令  不会阻塞redis的服务</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.服务器配置方式自动触发</span></span><br><span class="line"><span class="bullet">-</span> 配置redis.conf中的auto-aof-rewrite-percentage选项 参加下图↓↓↓</span><br><span class="line"><span class="bullet">-</span> 如果设置auto-aof-rewrite-percentage值为100和auto-aof-rewrite-min-size 64mb,并且启用的AOF持久化时,那么当AOF文件体积大于64M,并且AOF文件的体积比上一次重写之后体积大了至少一倍(100%)时,会自动触发,如果重写过于频繁,用户可以考虑将auto-aof-rewrite-percentage设置为更大</span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200623212547775.png" alt="image-20200623212547775"></p><h4 id="4-重写原理"><a href="#4-重写原理" class="headerlink" title="4. 重写原理"></a>4. 重写原理</h4><p> <strong>注意：重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件,替换原有的文件这点和快照有点类似。</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 重写流程</span></span><br><span class="line"><span class="bullet">-</span> 1. redis调用fork ，现在有父子两个进程 子进程根据内存中的数据库快照，往临时文件中写入重建数据库状态的命令</span><br><span class="line"><span class="bullet">-</span> 2. 父进程继续处理client请求，除了把写命令写入到原来的aof文件中。同时把收到的写命令缓存起来。这样就能保证如果子进程重写失败的话并不会出问题。</span><br><span class="line"><span class="bullet">-</span> 3. 当子进程把快照内容写入已命令方式写到临时文件中后，子进程发信号通知父进程。然后父进程把缓存的写命令也写入到临时文件。</span><br><span class="line"><span class="bullet">-</span> 4. 现在父进程可以使用临时文件替换老的aof文件，并重命名，后面收到的写命令也开始往新的aof文件中追加。</span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200623214843123.png" alt="image-20200623214843123"></p><hr><h3 id="9-4-持久化总结"><a href="#9-4-持久化总结" class="headerlink" title="9.4 持久化总结"></a>9.4 持久化总结</h3><p>两种持久化方案既可以同时使用(aof),又可以单独使用,在某种情况下也可以都不使用,具体使用那种持久化方案取决于用户的数据和应用决定。</p><p>无论使用AOF还是快照机制持久化,将数据持久化到硬盘都是有必要的,除了持久化外,用户还应该对持久化的文件进行备份(最好备份在多个不同地方)。</p><hr><h2 id="10-java操作Redis"><a href="#10-java操作Redis" class="headerlink" title="10. java操作Redis"></a>10. java操作Redis</h2><h3 id="10-1-环境准备"><a href="#10-1-环境准备" class="headerlink" title="10.1 环境准备"></a>10.1 环境准备</h3><h4 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入jedis连接依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-创建jedis对象"><a href="#2-创建jedis对象" class="headerlink" title="2.创建jedis对象"></a>2.创建jedis对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">//1.创建jedis对象</span></span><br><span class="line">  <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.40.4&quot;</span>, <span class="number">6379</span>);<span class="comment">//1.redis服务必须关闭防火墙  2.redis服务必须开启远程连接</span></span><br><span class="line">  jedis.select(<span class="number">0</span>);<span class="comment">//选择操作的库默认0号库</span></span><br><span class="line">  <span class="comment">//2.执行相关操作</span></span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">  <span class="comment">//3.释放资源</span></span><br><span class="line">  jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200623201932000.png" alt="image-20200623201932000"></p><h3 id="10-2-操作key相关API"><a href="#10-2-操作key相关API" class="headerlink" title="10.2 操作key相关API"></a>10.2 操作key相关API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Jedis jedis;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.202.205&quot;</span>, <span class="number">7000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试key相关</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testKeys</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//删除一个key</span></span><br><span class="line">        jedis.del(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//删除多个key</span></span><br><span class="line">        jedis.del(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断一个key是否存在exits</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">name</span> <span class="operator">=</span> jedis.exists(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置一个key超时时间 expire pexpire</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">age</span> <span class="operator">=</span> jedis.expire(<span class="string">&quot;age&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        System.out.println(age);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取一个key超时时间 ttl</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">age1</span> <span class="operator">=</span> jedis.ttl(<span class="string">&quot;newage&quot;</span>);</span><br><span class="line">        System.out.println(age1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//随机获取一个key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> jedis.randomKey();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改key名称</span></span><br><span class="line">        jedis.rename(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;newage&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查看可以对应值的类型</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> jedis.type(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name1);</span><br><span class="line">        <span class="type">String</span> <span class="variable">maps</span> <span class="operator">=</span> jedis.type(<span class="string">&quot;maps&quot;</span>);</span><br><span class="line">        System.out.println(maps);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200627180325687.png" alt="image-20200627180325687"></p><h3 id="10-3操作String相关API"><a href="#10-3操作String相关API" class="headerlink" title="10.3操作String相关API"></a>10.3操作String相关API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试String相关</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//set</span></span><br><span class="line">        jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;小陈&quot;</span>);</span><br><span class="line">        <span class="comment">//get</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="comment">//mset</span></span><br><span class="line">        jedis.mset(<span class="string">&quot;content&quot;</span>,<span class="string">&quot;好人&quot;</span>,<span class="string">&quot;address&quot;</span>,<span class="string">&quot;海淀区&quot;</span>);</span><br><span class="line">        <span class="comment">//mget</span></span><br><span class="line">        List&lt;String&gt; mget = jedis.mget(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;content&quot;</span>, <span class="string">&quot;address&quot;</span>);</span><br><span class="line">        mget.forEach(v-&gt; System.out.println(<span class="string">&quot;v = &quot;</span> + v));</span><br><span class="line">        <span class="comment">//getset</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">set</span> <span class="operator">=</span> jedis.getSet(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//............</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200627180352953.png" alt="image-20200627180352953"></p><h3 id="10-4操作List相关API"><a href="#10-4操作List相关API" class="headerlink" title="10.4操作List相关API"></a>10.4操作List相关API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试List相关</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//lpush</span></span><br><span class="line">        jedis.lpush(<span class="string">&quot;names1&quot;</span>,<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;赵柳&quot;</span>,<span class="string">&quot;win7&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//rpush</span></span><br><span class="line">        jedis.rpush(<span class="string">&quot;names1&quot;</span>,<span class="string">&quot;xiaomingming&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//lrange</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; names1 = jedis.lrange(<span class="string">&quot;names1&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        names1.forEach(name-&gt; System.out.println(<span class="string">&quot;name = &quot;</span> + name));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//lpop rpop</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">names11</span> <span class="operator">=</span> jedis.lpop(<span class="string">&quot;names1&quot;</span>);</span><br><span class="line">        System.out.println(names11);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//llen</span></span><br><span class="line">        <span class="comment">//BinaryClient.LIST_POSITION.BEFORE是一个枚举类，代表之前还是之后插入</span></span><br><span class="line">        jedis.linsert(<span class="string">&quot;lists&quot;</span>, BinaryClient.LIST_POSITION.BEFORE,<span class="string">&quot;xiaohei&quot;</span>,<span class="string">&quot;xiaobai&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//........</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200627180435997.png" alt="image-20200627180435997"></p><h3 id="10-5操作Set的相关API"><a href="#10-5操作Set的相关API" class="headerlink" title="10.5操作Set的相关API"></a>10.5操作Set的相关API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试SET相关</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//sadd</span></span><br><span class="line">  jedis.sadd(<span class="string">&quot;names&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//smembers</span></span><br><span class="line">  jedis.smembers(<span class="string">&quot;names&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//sismember</span></span><br><span class="line">  jedis.sismember(<span class="string">&quot;names&quot;</span>,<span class="string">&quot;xiaochen&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200627181913715.png" alt="image-20200627181913715"></p><h3 id="10-6-操作ZSet相关API"><a href="#10-6-操作ZSet相关API" class="headerlink" title="10.6 操作ZSet相关API"></a>10.6 操作ZSet相关API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试ZSET相关</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZset</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//zadd</span></span><br><span class="line">  jedis.zadd(<span class="string">&quot;names&quot;</span>,<span class="number">10</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//zrange</span></span><br><span class="line">  jedis.zrange(<span class="string">&quot;names&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//zcard</span></span><br><span class="line">  jedis.zcard(<span class="string">&quot;names&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//zrangeByScore</span></span><br><span class="line">  jedis.zrangeByScore(<span class="string">&quot;names&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;100&quot;</span>,<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200627181947116.png" alt="image-20200627181947116"></p><h3 id="10-7-操作Hash相关API"><a href="#10-7-操作Hash相关API" class="headerlink" title="10.7 操作Hash相关API"></a>10.7 操作Hash相关API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试HASH相关</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//hset</span></span><br><span class="line">  jedis.hset(<span class="string">&quot;maps&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">  <span class="comment">//hget</span></span><br><span class="line">  jedis.hget(<span class="string">&quot;maps&quot;</span>,<span class="string">&quot;name&quot;</span>);</span><br><span class="line">  <span class="comment">//hgetall</span></span><br><span class="line">  jedis.hgetAll(<span class="string">&quot;mps&quot;</span>);</span><br><span class="line">  <span class="comment">//hkeys</span></span><br><span class="line">  jedis.hkeys(<span class="string">&quot;maps&quot;</span>);</span><br><span class="line">  <span class="comment">//hvals</span></span><br><span class="line">  jedis.hvals(<span class="string">&quot;maps&quot;</span>);</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200628093242527.png" alt="image-20200628093242527"></p><hr><h2 id="11-SpringBoot整合Redis"><a href="#11-SpringBoot整合Redis" class="headerlink" title="11.SpringBoot整合Redis"></a>11.SpringBoot整合Redis</h2><p>Spring Boot Data(数据) Redis 中提供了<strong>RedisTemplate和StringRedisTemplate</strong>，其中StringRedisTemplate是RedisTemplate的子类，两个方法基本一致，不同之处主要体现在操作的数据类型不同，<strong>RedisTemplate中的两个泛型都是Object，意味着存储的key和value都可以是一个对象，而StringRedisTemplate的两个泛型都是String，意味着StringRedisTemplate的key和value都只能是字符串。</strong></p><p><strong><code>注意: 使用RedisTemplate默认是将对象序列化到Redis中,所以放入的对象必须实现对象序列化接口</code></strong></p><h3 id="11-1-环境准备"><a href="#11-1-环境准备" class="headerlink" title="11.1 环境准备"></a>11.1 环境准备</h3><h4 id="1-引入依赖-1"><a href="#1-引入依赖-1" class="headerlink" title="1.引入依赖"></a>1.引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-配置application-propertie"><a href="#2-配置application-propertie" class="headerlink" title="2.配置application.propertie"></a>2.配置application.propertie</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="attr">spring.redis.database</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure><h3 id="11-2-1使用StringRedisTemplate和"><a href="#11-2-1使用StringRedisTemplate和" class="headerlink" title="11.2 .1使用StringRedisTemplate和"></a>11.2 .1使用StringRedisTemplate和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动springboot应用</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = RedisDay2Application.class)</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStringRedisTemplate</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入StringRedisTemplate</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;  <span class="comment">//key  value 都是字符串</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作redis中key相关</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testKey</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//stringRedisTemplate.delete(&quot;name&quot;);//删除一个key</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">hasKey</span> <span class="operator">=</span> stringRedisTemplate.hasKey(<span class="string">&quot;name&quot;</span>);<span class="comment">//判断某个key是否存在</span></span><br><span class="line">        System.out.println(hasKey);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">DataType</span> <span class="variable">name</span> <span class="operator">=</span> stringRedisTemplate.type(<span class="string">&quot;name&quot;</span>);<span class="comment">//判断key所对应值的类型</span></span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; keys = stringRedisTemplate.keys(<span class="string">&quot;*&quot;</span>);<span class="comment">//获取redis中所有key</span></span><br><span class="line">        keys.forEach(key -&gt; System.out.println(<span class="string">&quot;key = &quot;</span> + key));</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">expire</span> <span class="operator">=</span> stringRedisTemplate.getExpire(<span class="string">&quot;age&quot;</span>);<span class="comment">//获取key超时时间 -1 永不超时  -2  key不存在 &gt;=0 过期时间</span></span><br><span class="line">        System.out.println(expire);</span><br><span class="line"></span><br><span class="line">        stringRedisTemplate.randomKey();<span class="comment">//在redis中随机获取一个key</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//stringRedisTemplate.rename(&quot;age&quot;,&quot;age1&quot;);//修改key名字 要求key必须存在 不存在 报错</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//stringRedisTemplate.renameIfAbsent(&quot;name&quot;,&quot;name1&quot;);//修改key名字  判断key是否存在</span></span><br><span class="line"></span><br><span class="line">        stringRedisTemplate.move(<span class="string">&quot;name1&quot;</span>,<span class="number">1</span>);<span class="comment">//移动key到指定库</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作redis中字符串 opsForValue 实际操作就是redis中String类型</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span>&#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;小陈&quot;</span>); <span class="comment">//set 用来设置一个key value</span></span><br><span class="line"></span><br><span class="line">        String value= stringRedisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>); <span class="comment">//用来获取一个key对应value</span></span><br><span class="line">        System.out.println(<span class="string">&quot;value = &quot;</span> + value);</span><br><span class="line"></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;code&quot;</span>,<span class="string">&quot;2357&quot;</span>,<span class="number">120</span>, TimeUnit.SECONDS);<span class="comment">//设置一个key 超时时间</span></span><br><span class="line"></span><br><span class="line">        stringRedisTemplate.opsForValue().append(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;他是是一个好人,单纯少年!&quot;</span>);<span class="comment">//追加</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作redis中list类型   opsForList 实际操作就是redis中list类型</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//stringRedisTemplate.opsForList().leftPush(&quot;names&quot;,&quot;小陈&quot;);//创建一个列表  并放入一个元素</span></span><br><span class="line">        <span class="comment">//stringRedisTemplate.opsForList().leftPushAll(&quot;names&quot;,&quot;小陈&quot;,&quot;小张&quot;,&quot;小王&quot;);//创建一个列表 放入多个元素</span></span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        names.add(<span class="string">&quot;xiaoming&quot;</span>);</span><br><span class="line">        names.add(<span class="string">&quot;xiaosan&quot;</span>);</span><br><span class="line">        <span class="comment">//stringRedisTemplate.opsForList().leftPushAll(&quot;names&quot;,names);//创建一个列表 放入多个元素</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; stringList = stringRedisTemplate.opsForList().range(<span class="string">&quot;names&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>); <span class="comment">//遍历list</span></span><br><span class="line">        stringList.forEach(value-&gt; System.out.println(<span class="string">&quot;value = &quot;</span> + value));</span><br><span class="line"></span><br><span class="line">        stringRedisTemplate.opsForList().trim(<span class="string">&quot;names&quot;</span>,<span class="number">1</span>,<span class="number">3</span>); <span class="comment">//截取指定区间的list</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作redis中set类型   opsForSet 实际操作就是redis中set类型</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span>&#123;</span><br><span class="line">        stringRedisTemplate.opsForSet().add(<span class="string">&quot;sets&quot;</span>,<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;小陈&quot;</span>,<span class="string">&quot;xiaoming&quot;</span>);<span class="comment">//创建set 并放入多个元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; sets = stringRedisTemplate.opsForSet().members(<span class="string">&quot;sets&quot;</span>);<span class="comment">//查看set中成员</span></span><br><span class="line">        sets.forEach(value-&gt; System.out.println(<span class="string">&quot;value = &quot;</span> + value));</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">size</span> <span class="operator">=</span> stringRedisTemplate.opsForSet().size(<span class="string">&quot;sets&quot;</span>);<span class="comment">//获取set集合元素个数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;size = &quot;</span> + size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作redis中Zset类型   opsForZSet 实际操作就是redis中Zset类型</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZset</span><span class="params">()</span>&#123;</span><br><span class="line">        stringRedisTemplate.opsForZSet().add(<span class="string">&quot;zsets&quot;</span>,<span class="string">&quot;小黑&quot;</span>,<span class="number">20</span>);<span class="comment">//创建并放入元素</span></span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; zsets = stringRedisTemplate.opsForZSet().range(<span class="string">&quot;zsets&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);<span class="comment">//指定范围查询</span></span><br><span class="line"></span><br><span class="line">        zsets.forEach(value-&gt; System.out.println(value));</span><br><span class="line">        System.out.println(<span class="string">&quot;=====================================&quot;</span>);</span><br><span class="line">        Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zsets1 = stringRedisTemplate.opsForZSet().rangeByScoreWithScores(<span class="string">&quot;zsets&quot;</span>, <span class="number">0</span>, <span class="number">1000</span>);<span class="comment">//获取指定元素以及分数</span></span><br><span class="line"></span><br><span class="line">        zsets1.forEach(typedTuple -&gt;&#123;</span><br><span class="line">            System.out.println(typedTuple.getValue());</span><br><span class="line">            System.out.println(typedTuple.getScore());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作redis中Hash类型   opsForHash 实际操作就是redis中Hash类型</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        stringRedisTemplate.opsForHash().put(<span class="string">&quot;maps&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>);<span class="comment">//创建一个hash类型 并放入key value</span></span><br><span class="line"></span><br><span class="line">        Map&lt;String,String&gt; map =  <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;12&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;bir&quot;</span>,<span class="string">&quot;2012-12-12&quot;</span>);</span><br><span class="line">        stringRedisTemplate.opsForHash().putAll(<span class="string">&quot;maps&quot;</span>,map);  <span class="comment">//放入多个key value</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;Object&gt; values = stringRedisTemplate.opsForHash().multiGet(<span class="string">&quot;maps&quot;</span>, Arrays.asList(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>));<span class="comment">//获取多个key的value</span></span><br><span class="line">        values.forEach(value-&gt; System.out.println(value));</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span>  <span class="operator">=</span> (String) stringRedisTemplate.opsForHash().get(<span class="string">&quot;maps&quot;</span>, <span class="string">&quot;name&quot;</span>);<span class="comment">//获取hash中某个key的值</span></span><br><span class="line"></span><br><span class="line">        List&lt;Object&gt; vals = stringRedisTemplate.opsForHash().values(<span class="string">&quot;maps&quot;</span>);<span class="comment">//获取所有values</span></span><br><span class="line"></span><br><span class="line">        Set&lt;Object&gt; keys = stringRedisTemplate.opsForHash().keys(<span class="string">&quot;maps&quot;</span>);<span class="comment">//获取所有keys</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="11-2-2使用RedisTemplate"><a href="#11-2-2使用RedisTemplate" class="headerlink" title="11.2.2使用RedisTemplate"></a>11.2.2使用RedisTemplate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动springboot应用</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = RedisDay2Application.class)</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRedisTemplate</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入RedisTemplate key Object  Value Object  ===&gt;   对象序列化   name  new User() ====&gt;   name序列化  对象序列化结果</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//opsForxxx  Value String  List  Set  Zset  hash</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRedisTemplate</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * redisTemplate对象中 key 和 value 的序列化都是 JdkSerializationRedisSerializer</span></span><br><span class="line"><span class="comment">         *      key: string</span></span><br><span class="line"><span class="comment">         *      value: object</span></span><br><span class="line"><span class="comment">         *      修改默认key序列化方案 :  key  StringRedisSerializer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改key序列化方案   String类型序列</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        <span class="comment">//修改hash key 序列化方案//这是改里面的map的key的序列化方案，为了显示成字符串的形式</span></span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(UUID.randomUUID().toString()).setName(<span class="string">&quot;小陈&quot;</span>).setAge(<span class="number">23</span>).setBir(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;user&quot;</span>, user);<span class="comment">//redis进行设置 对象需要经过序列化</span></span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> (User) redisTemplate.opsForValue().get(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(user1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        redisTemplate.opsForList().leftPush(<span class="string">&quot;list&quot;</span>,user);</span><br><span class="line"></span><br><span class="line">        redisTemplate.opsForSet().add(<span class="string">&quot;set&quot;</span>,user);</span><br><span class="line"></span><br><span class="line">        redisTemplate.opsForZSet().add(<span class="string">&quot;zset&quot;</span>,user,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        redisTemplate.opsForHash().put(<span class="string">&quot;map&quot;</span>,<span class="string">&quot;name&quot;</span>,user);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="11-2-3使用boundApi"><a href="#11-2-3使用boundApi" class="headerlink" title="11.2.3使用boundApi"></a>11.2.3使用boundApi</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(classes = RedisDay2Application.class)</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBoundAPI</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//spring data 为了方便我们对redis进行更友好的操作 因此有提供了bound api 简化操作</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBound</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//redisTemplate   stringRedisTemplate  将一个key多次操作进行绑定 对key绑定</span></span><br><span class="line">        <span class="comment">//stringRedisTemplate.opsForValue().set(&quot;name&quot;,&quot;zhangsan&quot;);</span></span><br><span class="line">        <span class="comment">//stringRedisTemplate.opsForValue().append(&quot;name&quot;,&quot;是一个好人&quot;);</span></span><br><span class="line">        <span class="comment">//String s = stringRedisTemplate.opsForValue().get(&quot;name&quot;);</span></span><br><span class="line">        <span class="comment">//System.out.println(s);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对字符串类型key进行绑定 后续所有操作都是基于这个key的操作</span></span><br><span class="line"></span><br><span class="line">        BoundValueOperations&lt;String, String&gt; nameValueOperations = stringRedisTemplate.boundValueOps(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        nameValueOperations.set(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        nameValueOperations.append(<span class="string">&quot;是一个好人&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> nameValueOperations.get();</span><br><span class="line">        System.out.println(s1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对list set zset hash</span></span><br><span class="line">        BoundListOperations&lt;String, String&gt; listsOperations = stringRedisTemplate.boundListOps(<span class="string">&quot;lists&quot;</span>);</span><br><span class="line">        listsOperations.leftPushAll(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;小陈&quot;</span>);</span><br><span class="line">        List&lt;String&gt; lists = listsOperations.range(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        lists.forEach(list-&gt; System.out.println(list));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//set</span></span><br><span class="line">        <span class="comment">//redisTemplate.boundSetOps();</span></span><br><span class="line">        <span class="comment">//stringRedisTemplate.boundSetOps()</span></span><br><span class="line">        <span class="comment">//zset</span></span><br><span class="line">        <span class="comment">//stringRedisTemplate.boundZSetOps();</span></span><br><span class="line">        <span class="comment">//redisTemplate.boundZSetOps();</span></span><br><span class="line">        <span class="comment">//hash</span></span><br><span class="line">        <span class="comment">//stringRedisTemplate.boundHashOps();</span></span><br><span class="line">        <span class="comment">//redisTemplate.boundHashOps()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.针对于日后处理key value 都是 String 使用 StringRedisTemplate</span></span><br><span class="line"><span class="comment">         * 2.针对于日后处理的key value 存在对象 使用 RedisTemplate</span></span><br><span class="line"><span class="comment">         * 3.针对于同一个key多次操作可以使用boundXXxOps() Value List Set Zset Hash的api 简化书写</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * redis应用场景</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *  1.利用redis 中字符串类型完成 项目中手机验证码存储的实现</span></span><br><span class="line"><span class="comment">         *  2.利用redis 中字符串类型完成 具有失效性业务功能  12306  淘宝  订单还有:40分钟</span></span><br><span class="line"><span class="comment">         *  3.利用redis 分布式集群系统中 Session共享  memcache 内存 数据存储上限 数据类型比较简单  redis 内存  数据上限  数据类型丰富</span></span><br><span class="line"><span class="comment">         *  4.利用redis zset类型 可排序set类型  元素 分数  排行榜之类功能   dangdang 销量排行  sales(zset) [商品id,商品销量] ......</span></span><br><span class="line"><span class="comment">         *  5.利用redis 分布式缓存  实现</span></span><br><span class="line"><span class="comment">         *  6.利用redis 存储认证之后token信息   微信小程序 微信公众号 |用户 openid   ---&gt; 令牌(token) redis 超时</span></span><br><span class="line"><span class="comment">         *  7.利用redis 解决分布式集群系统中分布式锁问题       redis 单进程 单线程   n 20 定义</span></span><br><span class="line"><span class="comment">         *      jvm  1进程开启多个线程 synchronize int n=20</span></span><br><span class="line"><span class="comment">         *      jvm  1进程开启多个线程 synchronize int n=20</span></span><br><span class="line"><span class="comment">         *      .....  LRA脚本</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="12-Redis-主从复制"><a href="#12-Redis-主从复制" class="headerlink" title="12. Redis 主从复制"></a>12. Redis 主从复制</h2><h3 id="12-1-主从复制"><a href="#12-1-主从复制" class="headerlink" title="12.1 主从复制"></a>12.1 主从复制</h3><p>主从复制架构仅仅用来解决数据的冗余备份,从节点仅仅用来同步数据</p><p><strong>无法解决: 1.master节点出现故障的自动故障转移</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.概念</span></span><br><span class="line"><span class="bullet">-</span> 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)；</span><br><span class="line"><span class="bullet">-</span> 数据的复制是单向的，只能由主节点到从节点。</span><br><span class="line"><span class="bullet">-</span> Master以写为主，Slave 以读为主。</span><br><span class="line"><span class="bullet">-</span> 默认情况下，每台Redis服务器都是主节点；</span><br><span class="line"><span class="bullet">-</span> 且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.主从复制的作用主要包括</span></span><br><span class="line"><span class="bullet">-</span> 1、数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</span><br><span class="line"><span class="bullet">-</span> 2、故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</span><br><span class="line"><span class="bullet">-</span> 3、负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节    点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</span><br><span class="line"><span class="bullet">-</span> 4、高可用（集群）基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</span><br><span class="line"></span><br><span class="line"><span class="section"># 3.不能只使用一台redis</span></span><br><span class="line"><span class="bullet">-</span> 1、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；</span><br><span class="line"><span class="bullet">-</span> 2、从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。</span><br></pre></td></tr></table></figure><h3 id="12-2-主从复制架构图"><a href="#12-2-主从复制架构图" class="headerlink" title="12.2 主从复制架构图"></a>12.2 主从复制架构图</h3><p>电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。</p><p>对于这种场景，我们可以使如下这种架构：</p><p><img src="/../Typora/img/image-20200627201722700.png" alt="image-20200627201722700"></p><p><strong><code>主从复制，读写分离！ 80% 的情况下都是在进行读操作！减缓服务器的压力！架构中经常使用！ 一主二从！ 只要在公司中，主从复制就是必须要使用的，因为在真实的项目中不可能单机使用Redis！</code></strong></p><h3 id="12-3-搭建主从复制"><a href="#12-3-搭建主从复制" class="headerlink" title="12.3 搭建主从复制"></a>12.3 搭建主从复制</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.准备3台机器并修改配置</span></span><br><span class="line"><span class="bullet">-</span> master</span><br><span class="line"><span class="code">port 6379</span></span><br><span class="line"><span class="code">bind 0.0.0.0</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">- slave1</span></span><br><span class="line"><span class="code">port 6380</span></span><br><span class="line"><span class="code">bind 0.0.0.0</span></span><br><span class="line"><span class="code">slaveof masterip masterport</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">-</span> slave2</span><br><span class="line"><span class="code">port 6381</span></span><br><span class="line"><span class="code">bind 0.0.0.0</span></span><br><span class="line"><span class="code">slaveof masterip masterport</span></span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200627202443388.png" alt="image-20200627202443388"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 2.启动3台机器进行测试</span></span><br><span class="line"><span class="bullet">-</span> cd /usr/redis/bin</span><br><span class="line"><span class="bullet">-</span> ./redis-server /root/master/redis.conf</span><br><span class="line"><span class="bullet">-</span> ./redis-server /root/slave1/redis.conf</span><br><span class="line"><span class="bullet">-</span> ./redis-server /root/slave2/redis.conf</span><br></pre></td></tr></table></figure><hr><p>测试：主机断开连接，从机依旧连接到主机的，但是没有写操作，这个时候，主机如果回来了，从机依旧可以直接获取到主机写的信息！</p><p>如果是使用命令行，来配置的主从，这个时候如果重启了，就会变回主机！只要变为从机，立马就会从主机中获取值！</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.复制原理</span></span><br><span class="line"><span class="bullet">-</span> Slave 启动成功连接到 master 后会发送一个sync同步命令，Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完  毕之后，master将传送整个数据文件到slave，并完成一次完全同步。</span><br><span class="line"><span class="bullet">-</span> 全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</span><br><span class="line"><span class="bullet">-</span> 增量复制：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步</span><br><span class="line"><span class="bullet">-</span> 但是只要是重新连接master，一次完全同步（全量复制）将被自动执行！ 我们的数据一定可以在从机中看到！</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.如果没有老大了，这个时候能不能选择一个老大出来呢？ 手动</span></span><br><span class="line"><span class="bullet">-</span> 如果主机断开了连接，我们可以使用SLAVEOF no one让自己变成主机！其他的节点就可以手动连接到最新的这个主节点（手动）！如果这个时候老大修复了，那就重新连   接！</span><br></pre></td></tr></table></figure><h2 id="13-Redis哨兵机制"><a href="#13-Redis哨兵机制" class="headerlink" title="13. Redis哨兵机制"></a>13. Redis哨兵机制</h2><h3 id="13-1-哨兵Sentinel机制"><a href="#13-1-哨兵Sentinel机制" class="headerlink" title="13.1 哨兵Sentinel机制"></a>13.1 哨兵Sentinel机制</h3><p>Sentinel（哨兵）是Redis 的高可用性解决方案：由一个或多个Sentinel 实例 组成的Sentinel 系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。简单的说哨兵就是带有<strong>自动故障转移功能的主从架构</strong>。</p><p><strong>无法解决: 1.单节点并发压力问题   2.单节点内存和磁盘物理上限</strong></p><h3 id="13-2-哨兵架构原理"><a href="#13-2-哨兵架构原理" class="headerlink" title="13.2 哨兵架构原理"></a>13.2 哨兵架构原理</h3><p><img src="/../Typora/img/image-20200627204422750.png" alt="image-20200627204422750"></p><h3 id="13-3-搭建哨兵架构"><a href="#13-3-搭建哨兵架构" class="headerlink" title="13.3 搭建哨兵架构"></a>13.3 搭建哨兵架构</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.在主节点上创建哨兵配置</span></span><br><span class="line"><span class="bullet">-</span> 在Master对应redis.conf同目录下新建sentinel.conf文件，名字绝对不能错；</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.配置哨兵，在sentinel.conf文件中填入内容：</span></span><br><span class="line"><span class="bullet">-</span> sentinel monitor 被监控数据库名字（自己起名字） ip port 1</span><br><span class="line"></span><br><span class="line"><span class="section"># 3.启动哨兵模式进行测试</span></span><br><span class="line"><span class="bullet">-</span> redis-sentinel  /root/sentinel/sentinel.conf</span><br><span class="line"><span class="code">说明:这个后面的数字2,是指当有两个及以上的sentinel服务检测到master宕机，才会去执行主从切换的功能。</span></span><br></pre></td></tr></table></figure><h3 id="13-4-通过springboot操作哨兵"><a href="#13-4-通过springboot操作哨兵" class="headerlink" title="13.4 通过springboot操作哨兵"></a>13.4 通过springboot操作哨兵</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis sentinel 配置</span></span><br><span class="line"><span class="comment"># master书写是使用哨兵监听的那个名称</span></span><br><span class="line"><span class="attr">spring.redis.sentinel.master</span>=<span class="string">mymaster</span></span><br><span class="line"><span class="comment"># 连接的不再是一个具体redis主机,书写的是多个哨兵节点</span></span><br><span class="line"><span class="attr">spring.redis.sentinel.nodes</span>=<span class="string">192.168.202.206:26379</span></span><br></pre></td></tr></table></figure><ul><li><strong>注意:如果连接过程中出现如下错误:RedisConnectionException: DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connect from external computers to Redis you may adopt one of the following solutions: 1) Just disable protected mode sending the command ‘CONFIG SET protected-mode no’ from the loopback interface by connecting to Redis from the same host the server is running, however MAKE SURE Redis is not publicly accessible from internet if you do so. Use CONFIG REWRITE to make this change permanent. 2)</strong></li><li><strong>解决方案:在哨兵的配置文件中加入bind 0.0.0.0 开启远程连接权限</strong></li></ul><p><img src="/../Typora/img/image-20200629154647970.png" alt="image-20200629154647970"></p><h2 id="14-Redis集群"><a href="#14-Redis集群" class="headerlink" title="14. Redis集群"></a>14. Redis集群</h2><h3 id="14-1-集群"><a href="#14-1-集群" class="headerlink" title="14.1 集群"></a>14.1 集群</h3><p>Redis在3.0后开始支持Cluster(模式)模式,目前redis的集群支持节点的自动发现,支持slave-master选举和容错,支持在线分片(sharding shard )等特性。reshard</p><h3 id="14-2-集群架构图"><a href="#14-2-集群架构图" class="headerlink" title="14.2 集群架构图"></a>14.2 集群架构图</h3><img src="../Typora/img/wpsgRnQP8.jpg" alt="img" style="zoom: 33%;" /><h3 id="14-3-集群细节"><a href="#14-3-集群细节" class="headerlink" title="14.3 集群细节"></a>14.3 集群细节</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.</span><br><span class="line"><span class="bullet">-</span> 节点的fail是通过集群中超过半数的节点检测失效时才生效. </span><br><span class="line"><span class="bullet">-</span> 客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可</span><br><span class="line"><span class="bullet">-</span> redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value</span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200629165226329.png" alt="image-20200629165226329"></p><h3 id="14-4-集群搭建"><a href="#14-4-集群搭建" class="headerlink" title="14.4 集群搭建"></a>14.4 集群搭建</h3><p>判断一个是集群中的节点是否可用,是集群中的所用主节点选举过程,如果半数以上的节点认为当前节点挂掉,那么当前节点就是挂掉了,所以搭建redis集群时建议节点数最好为奇数，<strong>搭建集群至少需要三个主节点,三个从节点,至少需要6个节点</strong>。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.准备环境安装ruby以及redis集群依赖</span></span><br><span class="line"><span class="bullet">-</span> yum install -y ruby rubygems</span><br><span class="line"><span class="bullet">-</span> gem install redis-xxx.gem</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200627193219366.png" alt="image-20200627193219366"></p><p><img src="/../Typora/img/image-20200627193348905.png" alt="image-20200627193348905"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 2.在一台机器创建7个目录</span></span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200627193849867.png" alt="image-20200627193849867"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 3.每个目录复制一份配置文件</span></span><br><span class="line">[root@localhost ~]# cp redis-4.0.10/redis.conf 7000/</span><br><span class="line">[root@localhost ~]# cp redis-4.0.10/redis.conf 7001/</span><br><span class="line">[root@localhost ~]# cp redis-4.0.10/redis.conf 7002/</span><br><span class="line">[root@localhost ~]# cp redis-4.0.10/redis.conf 7003/</span><br><span class="line">[root@localhost ~]# cp redis-4.0.10/redis.conf 7004/</span><br><span class="line">[root@localhost ~]# cp redis-4.0.10/redis.conf 7005/</span><br><span class="line">[root@localhost ~]# cp redis-4.0.10/redis.conf 7006/</span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200627194103354.png" alt="image-20200627194103354"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 4.修改不同目录配置文件</span></span><br><span class="line"><span class="bullet">-</span> port 6379 .....                 //修改端口</span><br><span class="line"><span class="bullet">-</span> bind  0.0.0.0                    //开启远程连接</span><br><span class="line"><span class="bullet">-</span> cluster-enabled  yes          //开启集群模式</span><br><span class="line"><span class="bullet">-</span> cluster-config-file  nodes-port.conf //集群节点配置文件</span><br><span class="line"><span class="bullet">-</span> cluster-node-timeout  5000         //集群节点超时时间</span><br><span class="line"><span class="bullet">-</span> appendonly  yes                  //开启AOF持久化</span><br><span class="line"></span><br><span class="line"><span class="section"># 5.指定不同目录配置文件启动七个节点</span></span><br><span class="line"><span class="bullet">-</span> [root@localhost bin]# ./redis-server  /root/7000/redis.conf</span><br><span class="line"><span class="bullet">-</span> [root@localhost bin]# ./redis-server  /root/7001/redis.conf</span><br><span class="line"><span class="bullet">-</span> [root@localhost bin]# ./redis-server  /root/7002/redis.conf</span><br><span class="line"><span class="bullet">-</span> [root@localhost bin]# ./redis-server  /root/7003/redis.conf</span><br><span class="line"><span class="bullet">-</span> [root@localhost bin]# ./redis-server  /root/7004/redis.conf</span><br><span class="line"><span class="bullet">-</span> [root@localhost bin]# ./redis-server  /root/7005/redis.conf</span><br><span class="line"><span class="bullet">-</span> [root@localhost bin]# ./redis-server  /root/7006/redis.conf</span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200627194913866.png" alt="image-20200627194913866"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 6.查看进程</span></span><br><span class="line"><span class="bullet">-</span> [root@localhost bin]# ps aux|grep redis</span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200627194954143.png" alt="image-20200627194954143"></p><h4 id="1-创建集群"><a href="#1-创建集群" class="headerlink" title="1.创建集群"></a>1.创建集群</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.复制集群操作脚本到bin目录中</span></span><br><span class="line"><span class="bullet">-</span> [root@localhost bin]# cp /root/redis-4.0.10/src/redis-trib.rb .</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.创建集群</span></span><br><span class="line"><span class="bullet">-</span> ./redis-trib.rb create --replicas 1 192.168.202.205:7000 192.168.202.205:7001 192.168.202.205:7002 192.168.202.205:7003 192.168.202.205:7004 192.168.202.205:7005</span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200627195601307.png" alt="image-20200627195601307"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 3.集群创建成功出现如下提示</span></span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20200627195647767.png" alt="image-20200627195647767"></p><h4 id="2-查看集群状态"><a href="#2-查看集群状态" class="headerlink" title="2.查看集群状态"></a>2.查看集群状态</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.查看集群状态 check [原始集群中任意节点] [无]</span></span><br><span class="line"><span class="bullet">-</span> ./redis-trib.rb check 192.168.202.205:7000</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.集群节点状态说明</span></span><br><span class="line"><span class="bullet">-</span> 主节点 </span><br><span class="line"><span class="code">主节点存在hash slots,且主节点的hash slots 没有交叉</span></span><br><span class="line"><span class="code">主节点不能删除</span></span><br><span class="line"><span class="code">一个主节点可以有多个从节点</span></span><br><span class="line"><span class="code">主节点宕机时多个副本之间自动选举主节点</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">-</span> 从节点</span><br><span class="line"><span class="code">从节点没有hash slots</span></span><br><span class="line"><span class="code">从节点可以删除</span></span><br><span class="line"><span class="code">从节点不负责数据的写,只负责数据的同步</span></span><br></pre></td></tr></table></figure><h4 id="3-添加主节点"><a href="#3-添加主节点" class="headerlink" title="3.添加主节点"></a>3.添加主节点</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.添加主节点 add-node [新加入节点] [原始集群中任意节点]</span></span><br><span class="line"><span class="bullet">-</span> ./redis-trib.rb  add-node 192.168.1.158:7006  192.168.1.158:7005</span><br><span class="line"><span class="bullet">-</span> 注意:</span><br><span class="line"><span class="code">1.该节点必须以集群模式启动</span></span><br><span class="line"><span class="code">2.默认情况下该节点就是以master节点形式添加</span></span><br></pre></td></tr></table></figure><h4 id="4-添加从节点"><a href="#4-添加从节点" class="headerlink" title="4.添加从节点"></a>4.添加从节点</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.添加从节点 add-node --slave [新加入节点] [集群中任意节点]</span></span><br><span class="line"><span class="bullet">-</span> ./redis-trib.rb  add-node --slave 192.168.1.158:7006 192.168.1.158:7000</span><br><span class="line"><span class="bullet">-</span> 注意:</span><br><span class="line"><span class="code">当添加副本节点时没有指定主节点,redis会随机给副本节点较少的主节点添加当前副本节点</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"># 2.为确定的master节点添加主节点 add-node --slave --master-id master节点id [新加入节点] [集群任意节点]</span></span><br><span class="line"><span class="code">- ./redis-trib.rb  add-node --slave --master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7006  127.0.0.1:7000</span></span><br></pre></td></tr></table></figure><h4 id="5-删除副本节点"><a href="#5-删除副本节点" class="headerlink" title="5.删除副本节点"></a>5.删除副本节点</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.删除节点 del-node [集群中任意节点] [删除节点id]</span></span><br><span class="line"><span class="bullet">-</span> ./redis-trib.rb  del-node 127.0.0.1:7002 0ca3f102ecf0c888fc7a7ce43a13e9be9f6d3dd1</span><br><span class="line"><span class="bullet">-</span> 注意:</span><br><span class="line"> 1.被删除的节点必须是从节点或没有被分配hash slots的节点</span><br></pre></td></tr></table></figure><h4 id="6-集群在线分片"><a href="#6-集群在线分片" class="headerlink" title="6.集群在线分片"></a>6.集群在线分片</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.在线分片 reshard [集群中任意节点] [无]</span></span><br><span class="line"><span class="bullet">-</span> ./redis-trib.rb  reshard  192.168.1.158:7000</span><br></pre></td></tr></table></figure><hr><h2 id="15-Redis实现分布式Session管理"><a href="#15-Redis实现分布式Session管理" class="headerlink" title="15.Redis实现分布式Session管理"></a>15.Redis实现分布式Session管理</h2><h3 id="15-1-管理机制"><a href="#15-1-管理机制" class="headerlink" title="15.1 管理机制"></a>15.1 管理机制</h3><p><strong>redis的session管理是利用spring提供的session管理解决方案,将一个应用session交给Redis存储,整个应用中所有session的请求都会去redis中获取对应的session数据。</strong></p><p><img src="/../Typora/img/image-20200628201643358.png" alt="image-20200628201643358"></p><h3 id="15-2-开发Session管理"><a href="#15-2-开发Session管理" class="headerlink" title="15.2 开发Session管理"></a>15.2 开发Session管理</h3><h4 id="1-引入依赖-2"><a href="#1-引入依赖-2" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-开发Session管理配置类"><a href="#2-开发Session管理配置类" class="headerlink" title="2. 开发Session管理配置类"></a>2. 开发Session管理配置类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisSessionManager</span> &#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-打包测试即可"><a href="#3-打包测试即可" class="headerlink" title="3.打包测试即可"></a>3.打包测试即可</h4><hr><h2 id="16-Redis分布式缓存"><a href="#16-Redis分布式缓存" class="headerlink" title="16.Redis分布式缓存"></a>16.Redis分布式缓存</h2><h3 id="16-1-缓存简介"><a href="#16-1-缓存简介" class="headerlink" title="16.1 缓存简介"></a>16.1 缓存简介</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.什么是缓存</span></span><br><span class="line"><span class="bullet">-</span> 计算机内存中一段数据</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.内存中数据的特点</span></span><br><span class="line"><span class="bullet">-</span> 读写快  断电立即丢失</span><br><span class="line"></span><br><span class="line"><span class="section"># 3.缓存解决了什么问题？</span></span><br><span class="line"><span class="bullet">-</span> 提高网络吞吐量提高网络运行效率</span><br><span class="line"><span class="bullet">-</span> 核心解决问题：缓存的存在是用来减轻数据库访问压力</span><br><span class="line"></span><br><span class="line"><span class="section"># 4.既然缓存能提高效率，那项目中所有数据加入缓存岂不是更好？</span></span><br><span class="line"><span class="bullet">-</span> 注意：使用缓存时一定是数据库中数据极少发生修改，更多用于查询这种情况</span><br><span class="line"></span><br><span class="line"><span class="section"># 5.本地缓存和分布式缓存的区别</span></span><br><span class="line"><span class="bullet">-</span> 本地缓存：存在应用服务器内存中数据称之为本地缓存</span><br><span class="line"><span class="bullet">-</span> 分布式缓存：存储在当前应用服务器内存之外数据称之为分布式缓存</span><br><span class="line"><span class="bullet">-</span> 集群：将同一种服务的多个节点放在一起共同对系统提供服务的过程称之为集群</span><br><span class="line"><span class="bullet">-</span> 分布式：有多个不同服务集群共同对系统提供服务这个系统称之为分布式系统</span><br><span class="line"></span><br><span class="line"><span class="section"># 6.利用mabatis自身本地缓存结合redis实现分布式缓存</span></span><br><span class="line"><span class="bullet">-</span> mabatis中应用级缓存（二级缓存） sqlsessionFactory级别缓存 所有会话共享</span><br><span class="line"><span class="bullet">-</span> 开启二级缓存：在mapper.xml中加入<span class="language-xml"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span> ---&gt;这个属于本地缓存</span><br><span class="line"><span class="bullet">-</span> 查看Cache标签缓存实现：mybatis底层默认使用的是 org.apache.ibatis.cache.iml.PerpetualCache实现</span><br><span class="line"><span class="bullet">-</span> 自定义Rediscache实现</span><br><span class="line"><span class="bullet">  -</span> 通过mybatis默认cache源码可知 可以使用自定义Cache类实现Cache接口 并对里面方法进行实现（public class RedisCache implements Cache)</span><br><span class="line"><span class="bullet">  -</span> 使用RedisCache实现(cache type = &quot;com.baizhi.cache.RedisCache&quot;/&gt;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="16-2-RedisCache"><a href="#16-2-RedisCache" class="headerlink" title="16.2 RedisCache"></a>16.2 RedisCache</h3><h4 id="16-2-1-缓存实现"><a href="#16-2-1-缓存实现" class="headerlink" title="16.2.1 缓存实现"></a>16.2.1 缓存实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义Redis缓存实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCache</span> <span class="keyword">implements</span> <span class="title class_">Cache</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前放入缓存的mapper的namespace</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//必须存在构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisCache</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;id:=====================&gt; &quot;</span> + id);</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回cache唯一标识</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//缓存放入值  redis RedisTemplate   StringRedisTemplate</span></span><br><span class="line"><span class="comment">//自动生成的K是namespace+调用的方法名，V则是查询的结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putObject</span><span class="params">(Object key, Object value)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;key:&quot;</span> + key.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;value:&quot;</span> + value);</span><br><span class="line"><span class="comment">//        //通过application工具类获取redisTemplate</span></span><br><span class="line"><span class="comment">//        RedisTemplate redisTemplate = (RedisTemplate) ApplicationContextUtils.getBean(&quot;redisTemplate&quot;);</span></span><br><span class="line"><span class="comment">//        redisTemplate.setKeySerializer(new StringRedisSerializer());</span></span><br><span class="line"><span class="comment">//        redisTemplate.setHashKeySerializer(new StringRedisSerializer());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用redishash类型作为缓存存储模型  key   hashkey  value</span></span><br><span class="line">        getRedisTemplate().opsForHash().put(id.toString(),getKeyToMD5(key.toString()),value);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(id.equals(<span class="string">&quot;com.baizhi.dao.UserDAO&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">//缓存超时  client  用户   client  员工</span></span><br><span class="line">            getRedisTemplate().expire(id.toString(),<span class="number">1</span>, TimeUnit.HOURS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(id.equals(<span class="string">&quot;com.baizhi.dao.CityDAO&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">//缓存超时  client  用户   client  员工</span></span><br><span class="line">            getRedisTemplate().expire(id.toString(),<span class="number">30</span>, TimeUnit.MINUTES);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//.....指定不同业务模块设置不同缓存超时时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取中获取数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;key:&quot;</span> + key.toString());</span><br><span class="line"><span class="comment">//        //通过application工具类获取redisTemplate</span></span><br><span class="line"><span class="comment">//        RedisTemplate redisTemplate = (RedisTemplate) ApplicationContextUtils.getBean(&quot;redisTemplate&quot;);</span></span><br><span class="line"><span class="comment">//        redisTemplate.setKeySerializer(new StringRedisSerializer());</span></span><br><span class="line"><span class="comment">//        redisTemplate.setHashKeySerializer(new StringRedisSerializer());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据key 从redis的hash类型中获取数据</span></span><br><span class="line">        <span class="keyword">return</span> getRedisTemplate().opsForHash().get(id.toString(), getKeyToMD5(key.toString()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意:这个方法为mybatis保留方法 默认没有实现 后续版本可能会实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">removeObject</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;根据指定key删除缓存&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;清空缓存~~~&quot;</span>);</span><br><span class="line">        <span class="comment">//清空namespace</span></span><br><span class="line">        getRedisTemplate().delete(id.toString());<span class="comment">//清空缓存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来计算缓存数量</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//获取hash中key value数量</span></span><br><span class="line">        <span class="keyword">return</span> getRedisTemplate().opsForHash().size(id.toString()).intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装redisTemplate</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate <span class="title function_">getRedisTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//通过application工具类获取redisTemplate</span></span><br><span class="line">        <span class="type">RedisTemplate</span> <span class="variable">redisTemplate</span> <span class="operator">=</span> (RedisTemplate) ApplicationContextUtils.getBean(<span class="string">&quot;redisTemplate&quot;</span>);</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装一个对key进行md5处理方法</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getKeyToMD5</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DigestUtils.md5DigestAsHex(key.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>获取redisTemplate实例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来获取springboot创建好的工厂</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextUtils</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保留下来工厂</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将创建好工厂以参数形式传递给这个类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供在工厂中获取对象的方法 //RedisTemplate  redisTemplate</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getBean</span><span class="params">(String beanName)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext.getBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>测试</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(classes = RedisDay2Application.class)</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestUserService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindAll</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        userService.findAll().forEach(u-&gt; System.out.println(<span class="string">&quot;u = &quot;</span> + u));<span class="comment">//操作数据库</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;==================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        userService.findAll().forEach(u-&gt; System.out.println(<span class="string">&quot;u = &quot;</span> + u));<span class="comment">//从redis中获取</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindOne</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">byId</span> <span class="operator">=</span> userService.findById(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;==================================&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">byId1</span> <span class="operator">=</span> userService.findById(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span>&#123;<span class="comment">//增删改会清空redis缓存的数据，下次再次查询的时候会重新进行数据库的查询</span></span><br><span class="line">        userService.delete(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSave</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;百知教育&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">23</span>);</span><br><span class="line">        user.setBir(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        userService.save(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(<span class="string">&quot;7d8a2945-0271-4aa0-bea6-9945a2050ff2&quot;</span>).setName(<span class="string">&quot;小陈&quot;</span>).setAge(<span class="number">23</span>).setBir(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        userService.update(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>mapper缓存</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.baizhi.dao.UserDAO&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启mybatis二级缓存--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span>  <span class="attr">type</span>=<span class="string">&quot;com.baizhi.cache.RedisCache&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--findAll--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        select id,name,age,bir from t_user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--findById--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        select id,name,age,bir from t_user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--delete--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;delete&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span> &gt;</span></span><br><span class="line">        delete from t_user where id= #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--save--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;save&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span> &gt;</span></span><br><span class="line">        insert into t_user values(#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;,#&#123;bir&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--update--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        update t_user</span><br><span class="line">        set name=#&#123;name&#125;,age=#&#123;age&#125;,bir=#&#123;bir&#125;</span><br><span class="line">        where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="16-2-2-缓存关联"><a href="#16-2-2-缓存关联" class="headerlink" title="16.2.2 缓存关联"></a>16.2.2 缓存关联</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.缓存项目中应用</span></span><br><span class="line"><span class="bullet">-</span> 如果项目中表查询之间没有任何关联查询使用现在的这种缓存方式没有任何问题</span><br><span class="line"><span class="bullet">-</span> 现有缓存方式在表连接查询过程中一定存在问题？</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.在nybatis的缓存中如何解决关联关系时更新缓存信息的问题？</span></span><br><span class="line"><span class="bullet">-</span> <span class="language-xml"><span class="tag">&lt;<span class="name">cache-ref</span> /&gt;</span></span>用来将多个具有关联关系查询缓存放在一起处理</span><br><span class="line"></span><br><span class="line"><span class="section"># 3.例子</span></span><br><span class="line"><span class="bullet">-</span> 假如User表中关联了Emp表，现在对Emp中进行增删改的操作，如果不进行缓存的关联，则User中的redis缓存不会更新Emp的数据</span><br><span class="line"><span class="bullet">-</span> 在关联缓存之后，Emp进行增删改操作之后，会删除其redis的缓存，此时User中的数据也会同事进行更新</span><br></pre></td></tr></table></figure><p><img src="/../Typora/img/image-20210316193801277.png" alt="image-20210316193801277"></p><h4 id="16-2-3-缓存优化"><a href="#16-2-3-缓存优化" class="headerlink" title="16.2.3 缓存优化"></a>16.2.3 缓存优化</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.缓存优化策略</span></span><br><span class="line"><span class="bullet">-</span> 对放入redis中key进行优化：key的长度不能太长</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.如何将key设计的简洁一些？</span></span><br><span class="line"><span class="bullet">-</span> 算法：MD5加密处理</span><br><span class="line"><span class="bullet">-</span> 特点：</span><br><span class="line"><span class="bullet">      -</span> 一切文件字符串等经过md5处理之后，都会生成32位16禁止的字符串</span><br><span class="line"><span class="bullet">      -</span> 不同内容文件经过md5进行加密，加密结果几乎不可能一致</span><br><span class="line"><span class="bullet">      -</span> 相当内容文件多次经过md5生成的结果始终一致</span><br><span class="line"><span class="bullet">-</span> 推荐：</span><br><span class="line"><span class="bullet">  -</span> 在redis整合mybatis中建议将KEY进行md5优化处理</span><br></pre></td></tr></table></figure><h3 id="16-3-缓存穿透（查不到）"><a href="#16-3-缓存穿透（查不到）" class="headerlink" title="16.3 缓存穿透（查不到）"></a>16.3 缓存穿透（查不到）</h3><h4 id="16-3-1-概念"><a href="#16-3-1-概念" class="headerlink" title="16.3.1 概念"></a>16.3.1 概念</h4><p>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失</p><p>败。当用户很多的时候，缓存都没有命中（秒杀！），于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p><h4 id="16-3-2-解决方法"><a href="#16-3-2-解决方法" class="headerlink" title="16.3.2 解决方法"></a>16.3.2 解决方法</h4><blockquote><p>布隆过滤器</p></blockquote><p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；</p><img src="D:\Typora\img\image-20210319105059409.png" alt="image-20210319105059409" style="zoom:67%;" /><blockquote><p>缓存空对象</p></blockquote><p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；</p><img src="D:\Typora\img\image-20210319105130879.png" alt="image-20210319105130879" style="zoom:67%;" /><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.问题</span></span><br><span class="line"><span class="bullet">-</span> 1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；</span><br><span class="line"><span class="bullet">-</span> 2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</span><br></pre></td></tr></table></figure><h3 id="16-4-缓存击穿（量太大，缓存过期！）"><a href="#16-4-缓存击穿（量太大，缓存过期！）" class="headerlink" title="16.4 缓存击穿（量太大，缓存过期！）"></a>16.4 缓存击穿（量太大，缓存过期！）</h3><h4 id="16-4-1-概念"><a href="#16-4-1-概念" class="headerlink" title="16.4.1 概念"></a>16.4.1 概念</h4><p>这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大</p><p>并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过</p><p>期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。</p><h4 id="16-4-2-解决方法"><a href="#16-4-2-解决方法" class="headerlink" title="16.4.2 解决方法"></a>16.4.2 解决方法</h4><blockquote><p>设置热点数据永不过期</p></blockquote><p>从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。</p><blockquote><p>加互斥锁</p></blockquote><p>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的</p><p>压力转移到了分布式锁，因此对分布式锁的考验很大。</p><img src="D:\Typora\img\image-20210319105557054.png" alt="image-20210319105557054" style="zoom:67%;" /><h3 id="16-5-缓存雪崩"><a href="#16-5-缓存雪崩" class="headerlink" title="16.5 缓存雪崩"></a>16.5 缓存雪崩</h3><h4 id="16-5-1-概念"><a href="#16-5-1-概念" class="headerlink" title="16.5.1 概念"></a>16.5.1 概念</h4><p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis 宕机！产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢</p><p>购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数</p><p>据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p><img src="D:\Typora\img\image-20210319105736640.png" alt="image-20210319105736640" style="zoom:67%;" /><h4 id="16-5-2-解决方法"><a href="#16-5-2-解决方法" class="headerlink" title="16.5.2 解决方法"></a>16.5.2 解决方法</h4><blockquote><p>redis高可用</p></blockquote><p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续<br>工作，其实就是搭建的集群。（异地多活！）</p><blockquote><p>限流降级（在SpringCloud讲解过！）</p></blockquote><p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对<br>某个key只允许一个线程查询数据和写缓存，其他线程等待。</p><blockquote><p>数据预热</p></blockquote><p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数<br>据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让<br>缓存失效的时间点尽量均匀。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
