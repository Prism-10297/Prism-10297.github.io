<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DFS框架&amp;岛屿</title>
      <link href="/2022/04/23/DFS%E6%A1%86%E6%9E%B6&amp;%E5%B2%9B%E5%B1%BF/"/>
      <url>/2022/04/23/DFS%E6%A1%86%E6%9E%B6&amp;%E5%B2%9B%E5%B1%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="岛屿类问题的通用解法、DFS-遍历框架"><a href="#岛屿类问题的通用解法、DFS-遍历框架" class="headerlink" title="岛屿类问题的通用解法、DFS 遍历框架"></a>岛屿类问题的通用解法、DFS 遍历框架</h3><p>我们所熟悉的 DFS（深度优先搜索）问题通常是在树或者图结构上进行的。而我们今天要讨论的 DFS 问题，是在一种「网格」结构中进行的。岛屿问题是这类网格 DFS 问题的典型代表。网格结构遍历起来要比二叉树复杂一些，如果没有掌握一定的方法，DFS 代码容易写得冗长繁杂。</p><p>本文将以岛屿问题为例，展示网格类问题 DFS 通用思路，以及如何让代码变得简洁。</p><h4 id="网格类问题的-DFS-遍历方法"><a href="#网格类问题的-DFS-遍历方法" class="headerlink" title="网格类问题的 DFS 遍历方法"></a>网格类问题的 DFS 遍历方法</h4><p><code>网格问题的基本概念</code><br>我们首先明确一下岛屿问题中的网格结构是如何定义的，以方便我们后面的讨论。</p><p>网格问题是由 m \times nm×n 个小方格组成一个网格，每个小方格与其上下左右四个方格认为是相邻的，要在这样的网格上进行某种搜索。</p><p>岛屿问题是一类典型的网格问题。每个格子中的数字可能是 0 或者 1。我们把数字为 0 的格子看成海洋格子，数字为 1 的格子看成陆地格子，这样相邻的陆地格子就连接成一个岛屿。</p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/202204231120449.jpeg" style="zoom: 67%;" /><p>在这样一个设定下，就出现了各种岛屿问题的变种，包括岛屿的数量、面积、周长等。不过这些问题，基本都可以用 DFS 遍历来解决。</p><p><code>DFS 的基本结构</code><br>网格结构要比二叉树结构稍微复杂一些，它其实是一种简化版的图结构。要写好网格上的 DFS 遍历，我们首先要理解二叉树上的 DFS 遍历方法，再类比写出网格结构上的 DFS 遍历。我们写的二叉树 DFS 遍历一般是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问两个相邻结点：左子结点、右子结点</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，二叉树的 DFS 有两个要素：「访问相邻结点」和「判断 base case」。</p><p>第一个要素是<strong>访问相邻结点</strong>。二叉树的相邻结点非常简单，只有左子结点和右子结点两个。二叉树本身就是一个递归定义的结构：一棵二叉树，它的左子树和右子树也是一棵二叉树。那么我们的 DFS 遍历只需要递归调用左子树和右子树即可。</p><p>第二个要素是 <strong>判断 base case</strong>。一般来说，二叉树遍历的 base case 是 root &#x3D;&#x3D; null。这样一个条件判断其实有两个含义：一方面，这表示 root 指向的子树为空，不需要再往下遍历了。另一方面，在 root &#x3D;&#x3D; null 的时候及时返回，可以让后面的 root.left 和 root.right 操作不会出现空指针异常。</p><p>对于网格上的 DFS，我们完全可以参考二叉树的 DFS，写出网格 DFS 的两个要素：</p><p>首先，网格结构中的格子有多少相邻结点？答案是上下左右四个。对于格子 (r, c) 来说（r 和 c 分别代表行坐标和列坐标），四个相邻的格子分别是 (r-1, c)、(r+1, c)、(r, c-1)、(r, c+1)。换句话说，网格结构是「四叉」的。</p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/202204231120179.jpeg" style="zoom:67%;" /><p>其次，网格 DFS 中的 base case 是什么？从二叉树的 base case 对应过来，应该是网格中不需要继续遍历、grid[r][c] 会出现数组下标越界异常的格子，也就是那些超出网格范围的格子。</p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/202204231120093.jpeg" style="zoom:67%;" /><p>这一点稍微有些反直觉，坐标竟然可以临时超出网格的范围？这种方法我称为「先污染后治理」—— 甭管当前是在哪个格子，先往四个方向走一步再说，如果发现走出了网格范围再赶紧返回。这跟二叉树的遍历方法是一样的，先递归调用，发现 root &#x3D;&#x3D; null 再返回。</p><p>这样，我们得到了网格 DFS 遍历的框架代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 base case</span></span><br><span class="line">    <span class="comment">// 如果坐标 (r, c) 超出了网格范围，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, r, c)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问上、下、左、右四个相邻结点</span></span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断坐标 (r, c) 是否在网格中</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">inArea</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">        &amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>如何避免重复遍历</code><br>网格结构的 DFS 与二叉树的 DFS 最大的不同之处在于，遍历中可能遇到遍历过的结点。这是因为，网格结构本质上是一个「图」，我们可以把每个格子看成图中的结点，每个结点有向上下左右的四条边。在图中遍历时，自然可能遇到重复遍历结点。</p><p>这时候，DFS 可能会不停地「兜圈子」，永远停不下来，如下图所示：</p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/202204231120000.gif" style="zoom:67%;" /><p>如何避免这样的重复遍历呢？答案是标记已经遍历过的格子。以岛屿问题为例，我们需要在所有值为 1 的陆地格子上做 DFS 遍历。每走过一个陆地格子，就把格子的值改为 2，这样当我们遇到 2 的时候，就知道这是遍历过的格子了。也就是说，每个格子可能取三个值：</p><ul><li>0 —— 海洋格子</li><li>1 —— 陆地格子（未遍历过）</li><li>2 —— 陆地格子（已遍历过）</li></ul><p>我们在框架代码中加入避免重复遍历的语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 base case</span></span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, r, c)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果这个格子不是岛屿，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] = <span class="number">2</span>; <span class="comment">// 将格子标记为「已遍历过」</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问上、下、左、右四个相邻结点</span></span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断坐标 (r, c) 是否在网格中</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">inArea</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">        &amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/202204231122090.gif" style="zoom:67%;" /><p>这样，我们就得到了一个岛屿问题、乃至各种网格问题的通用 DFS 遍历方法。以下所讲的几个例题，其实都只需要在 DFS 遍历框架上稍加修改而已。</p><p><strong>小贴士：</strong></p><blockquote><p>在一些题解中，可能会把「已遍历过的陆地格子」标记为和海洋格子一样的 0，美其名曰「陆地沉没方法」，即遍历完一个陆地格子就让陆地「沉没」为海洋。这种方法看似很巧妙，但实际上有很大隐患，因为这样我们就无法区分「海洋格子」和「已遍历过的陆地格子」了。如果题目更复杂一点，这很容易出 bug。</p></blockquote><h4 id="岛屿问题的解法"><a href="#岛屿问题的解法" class="headerlink" title="岛屿问题的解法"></a>岛屿问题的解法</h4><p>理解了网格结构的 DFS 遍历方法以后，岛屿问题就不难解决了。下面我们分别看看三个题目该如何用 DFS 遍历来求解。</p><h5 id="例题-1：岛屿的最大面积"><a href="#例题-1：岛屿的最大面积" class="headerlink" title="例题 1：岛屿的最大面积"></a>例题 1：岛屿的最大面积</h5><blockquote><p>给定一个包含了一些 0 和 1 的非空二维数组 grid，一个岛屿是一组相邻的 1（代表陆地），这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表海洋）包围着。</p></blockquote><p>找到给定的二维数组中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。</p><p>这道题目只需要对每个岛屿做 DFS 遍历，求出每个岛屿的面积就可以了。求岛屿面积的方法也很简单，代码如下，每遍历到一个格子，就把面积加一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">area</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> </span><br><span class="line">        + area(grid, r - <span class="number">1</span>, c)</span><br><span class="line">        + area(grid, r + <span class="number">1</span>, c)</span><br><span class="line">        + area(grid, r, c - <span class="number">1</span>)</span><br><span class="line">        + area(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终我们得到的完整题解代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxAreaOfIsland</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; grid.length; r++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; grid[<span class="number">0</span>].length; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[r][c] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> area(grid, r, c);</span><br><span class="line">                res = Math.max(res, a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">area</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, r, c)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> </span><br><span class="line">        + area(grid, r - <span class="number">1</span>, c)</span><br><span class="line">        + area(grid, r + <span class="number">1</span>, c)</span><br><span class="line">        + area(grid, r, c - <span class="number">1</span>)</span><br><span class="line">        + area(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">inArea</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">        &amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="例题-2：填海造陆问题"><a href="#例题-2：填海造陆问题" class="headerlink" title="例题 2：填海造陆问题"></a>例题 2：填海造陆问题</h5><blockquote><p>在二维地图上， 0 代表海洋，1代表陆地，我们最多只能将一格 0 （海洋）变成 1 （陆地）。进行填海之后，地图上最大的岛屿面积是多少？</p></blockquote><p>这道题是岛屿最大面积问题的升级版。现在我们有填海造陆的能力，可以把一个海洋格子变成陆地格子，进而让两块岛屿连成一块。那么填海造陆之后，最大可能构造出多大的岛屿呢？</p><p>大致的思路我们不难想到，我们先计算出所有岛屿的面积，在所有的格子上标记出岛屿的面积。然后搜索哪个海洋格子相邻的两个岛屿面积最大。例如下图中红色方框内的海洋格子，上边、左边都与岛屿相邻，我们可以计算出它变成陆地之后可以连接成的岛屿面积为 7+1+2&#x3D;10。</p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/202204231135760.jpeg" style="zoom:67%;" /><p>然而，这种做法可能遇到一个问题。如下图中红色方框内的海洋格子，它的上边、左边都与岛屿相邻，这时候连接成的岛屿面积难道是 7+1+7？显然不是。这两个 7 来自同一个岛屿，所以填海造陆之后得到的岛屿面积应该只有 7+1 &#x3D; 8。</p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/202204231135854.jpeg" style="zoom:67%;" /><p>可以看到，要让算法正确，我们得能区分一个海洋格子相邻的两个 7 是不是来自同一个岛屿。那么，我们不能在方格中标记岛屿的面积，而应该标记岛屿的索引（下标），另外用一个数组记录每个岛屿的面积，如下图所示。这样我们就可以发现红色方框内的海洋格子，它的「两个」相邻的岛屿实际上是同一个。</p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/202204231136856.jpeg" style="zoom:67%;" /><p>可以看到，这道题实际上是对网格做了两遍 DFS：第一遍 DFS 遍历陆地格子，计算每个岛屿的面积并标记岛屿；第二遍 DFS 遍历海洋格子，观察每个海洋格子相邻的陆地格子。</p><p>这道题的基本思路就是这样，具体的代码还有一些需要注意的细节，但和本文的主题已经联系不大。各位可以自己思考一下如何把上述思路转化为代码。</p><h5 id="例题-3：岛屿的周长"><a href="#例题-3：岛屿的周长" class="headerlink" title="例题 3：岛屿的周长"></a>例题 3：岛屿的周长</h5><blockquote><p>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地，0 表示海洋。网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（一个或多个表示陆地的格子相连组成岛屿）。岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。计算这个岛屿的周长。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/202204231138541.jpeg" style="zoom:67%;" /><p>实话说，这道题用 DFS 来解并不是最优的方法。对于岛屿，直接用数学的方法求周长会更容易。不过这道题是一个很好的理解 DFS 遍历过程的例题，不信你跟着我往下看。</p><p>我们再回顾一下 网格 DFS 遍历的基本框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 base case</span></span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, r, c)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果这个格子不是岛屿，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] = <span class="number">2</span>; <span class="comment">// 将格子标记为「已遍历过」</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问上、下、左、右四个相邻结点</span></span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断坐标 (r, c) 是否在网格中</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">inArea</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">        &amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，dfs 函数直接返回有这几种情况：</p><ul><li>!inArea(grid, r, c)，即坐标 (r, c) 超出了网格的范围，也就是我所说的「先污染后治理」的情况</li><li>grid[r] [c] !&#x3D; 1即当前格子不是岛屿格子，这又分为两种情况：<ul><li>grid[r] [c]&#x3D;&#x3D; 0，当前格子是海洋格子</li><li>grid[r] [c]&#x3D;&#x3D; 2，当前格子是已遍历的陆地格子</li></ul></li></ul><p>那么这些和我们岛屿的周长有什么关系呢？实际上，岛屿的周长是计算岛屿全部的「边缘」，而这些边缘就是我们在 DFS 遍历中，dfs 函数返回的位置。观察题目示例，我们可以将岛屿的周长中的边分为两类，如下图所示。黄色的边是与网格边界相邻的周长，而蓝色的边是与海洋格子相邻的周长。</p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/202204231142077.jpeg" style="zoom:67%;" /><p>当我们的 dfs 函数因为「坐标 (r, c) 超出网格范围」返回的时候，实际上就经过了一条黄色的边；而当函数因为「当前格子是海洋格子」返回的时候，实际上就经过了一条蓝色的边。这样，我们就把岛屿的周长跟 DFS 遍历联系起来了，我们的题解代码也呼之欲出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">islandPerimeter</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; grid.length; r++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; grid[<span class="number">0</span>].length; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[r][c] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 题目限制只有一个岛屿，计算一个即可</span></span><br><span class="line">                <span class="keyword">return</span> dfs(grid, r, c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="comment">// 函数因为「坐标 (r, c) 超出网格范围」返回，对应一条黄色的边</span></span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, r, c)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数因为「当前格子是海洋格子」返回，对应一条蓝色的边</span></span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数因为「当前格子是已遍历的陆地格子」返回，和周长没关系</span></span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> dfs(grid, r - <span class="number">1</span>, c)</span><br><span class="line">        + dfs(grid, r + <span class="number">1</span>, c)</span><br><span class="line">        + dfs(grid, r, c - <span class="number">1</span>)</span><br><span class="line">        + dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断坐标 (r, c) 是否在网格中</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">inArea</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">        &amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong><br>对比完三个例题的题解代码，你会发现网格问题的代码真的都非常相似。其实这一类问题属于「会了不难」类型。了解树、图的基本遍历方法，再学会一点小技巧，掌握网格 DFS 遍历就一点也不难了。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora</title>
      <link href="/2022/04/22/Typora/"/>
      <url>/2022/04/22/Typora/</url>
      
        <content type="html"><![CDATA[<h2 id="MarkDown"><a href="#MarkDown" class="headerlink" title="MarkDown"></a>MarkDown</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>Markdown 是一种轻量级标记语言，创始人为 John Gruber。它允许人们「使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者 HTML）文档」。</p></blockquote><h3 id="为什么要用MarkDown"><a href="#为什么要用MarkDown" class="headerlink" title="为什么要用MarkDown"></a>为什么要用MarkDown</h3><p>对于我而言，我选择MarkDown的原因如下：</p><ol><li>回归到内容本身，注重文章本身的结构，而不是样式<ul><li>不需要考虑字体大小、颜色等，因为 Markdown 中字体样式都与结构有关，无法手动设置</li></ul></li><li>MarkDown的语法简单，记住几个常用的就可以释放鼠标了<ul><li>比如，我想要将 “这是个标题” 设置成二级标题，只需要在标题前添加<code>##</code>+空格即可实现，而不需要用鼠标先选中 “这是个标题”，然后在设置成二级标题</li></ul></li><li>当前许多网站都支持用 Markdown 来撰写文档<ul><li>如 博客园、CSDN、简书、语雀 等，有了这么多网站的支持，你可以随时随地上传本地 MarkDown 文件到博客中</li></ul></li></ol><h2 id="MarkDown-基本语法"><a href="#MarkDown-基本语法" class="headerlink" title="MarkDown 基本语法"></a>MarkDown 基本语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>语法格式：<code>#+空格+标题</code>，一个<code>#</code>是一级标题，两个<code>##</code>是两级标题，以此类推，支持六级标题。</p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><ul><li><p><strong>加粗</strong><br>语法格式：<code>**加粗**</code></p></li><li><p><em>斜体</em><br>语法格式：<code>*斜体*</code></p></li><li><p><em><strong>斜体加粗</strong></em><br>语法格式：&#96;&#96;<em><strong>斜体加粗</strong></em>&#96;</p></li><li><p>删除线<br>语法格式：<code>~~删除线~~</code></p></li><li><p>高亮</p><p>语法格式：<code>==高亮==</code></p></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>语法格式：<code>&gt;+引用文字</code></p><blockquote><p>我是引用文字</p></blockquote><p>引用也可以嵌套：</p><blockquote><blockquote><p>如加两个<code>&gt;&gt;</code></p><blockquote><p>三个<code>&gt;&gt;&gt;</code></p></blockquote></blockquote></blockquote><p>支持无线套娃~~</p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>语法格式：三个或者三个以上的 - 或者 * 都可以，如<code>***</code></p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>语法格式：<code>![alt](图片地址)</code></p><blockquote><p>alt 指的是当图片链接失效时显示的提示文字，最好设置 alt 为本地存储的图片名，方便查找</p></blockquote><p>如果你想要调整图片大小，有两种方式：</p><ol><li>右击图片，选择缩放图片</li><li>通过HTML调节，格式如下：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">&quot;border-radius: 20px;&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">src</span>=<span class="string">&quot;#&quot;</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">alt</span>=<span class="string">&quot;#&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">width</span>=<span class="string">&quot;688&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;center&gt;</code>标签设置图片居中对齐</li><li><code>border-radius</code>设置圆角</li><li><code>src</code>放置图片路径（本地路径或网络路径）</li><li><code>alt</code>放置图片链接失效后的显示文字</li><li><code>width</code>设置图片宽度（<code>witdh</code>和<code>height</code>只设置一个即可，等比例缩放）</li></ul><p>你也可以通过如下代码为图片添加图注：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">width</span>=<span class="string">&quot;688&quot;</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">src</span>=<span class="string">&quot;&quot;</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color: #999;&quot;</span>&gt;</span></span><br><span class="line">        图注</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p>语法格式：<code>[超链接名](超链接地址)</code></p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul><li>无序列表<ul><li>语法格式：无序列表用 - + * 任何一种都可以，如<code>+ 我是无序列表</code></li></ul></li></ul><blockquote><p>加号和内容之间需要放置一个空格</p></blockquote><ul><li>有序列表<ul><li>语法格式：<code>数字+点+空格+内容</code>，如<code>1. 我是有序列表</code></li></ul></li><li>子列表<ul><li>在子列表前按下tab键即可构成子列表。</li></ul></li></ul><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>语法格式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|左对齐|居中对齐|右对齐|</span><br><span class="line">|:----|:----:|---:|</span><br><span class="line">|左|中|右|</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">左对齐</th><th align="center">居中对齐</th><th align="right">右对齐</th></tr></thead><tbody><tr><td align="left">左</td><td align="center">中</td><td align="right">右</td></tr></tbody></table><blockquote><p>第二行分割表头和内容，并声明内容的对齐格式。<br>一般而言，不这么用，感觉太费劲了，下面再介绍快捷键。</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li>行内代码<ul><li>语法格式：用一个反引号包起来 <code>代码内容</code>，代码会以主题中设置的样式出现在行内，但不会实现代码高亮。</li></ul></li><li>多行代码<ul><li>语法格式：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</li></ul></li></ul><blockquote><p>`&#96;&#96; 语言<br>代码内容<br>`&#96;&#96;<br>语言：C、C++、JAVA 等</p></blockquote><h3 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h3><h4 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h4><blockquote><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符</p></blockquote><p>Markdown 使用反斜杠转义特殊字符：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   下划线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  小括号</span><br><span class="line">#   井字号</span><br><span class="line"><span class="addition">+   加号</span></span><br><span class="line"><span class="deletion">-   减号</span></span><br><span class="line">.   英文句点</span><br><span class="line"><span class="addition">!   感叹号</span></span><br></pre></td></tr></table></figure><h4 id="行内公式（inline）"><a href="#行内公式（inline）" class="headerlink" title="行内公式（inline）"></a>行内公式（inline）</h4><p>用 <code>$...$</code> 括起公式，公式会出现在行内。</p><h4 id="块间公式（display）"><a href="#块间公式（display）" class="headerlink" title="块间公式（display）"></a>块间公式（display）</h4><p>用 <code>$$...$$</code> 括起公式（注意 <code>$$</code> 后需要换行），公式会默认显示在行中间。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span><span class="variable">$</span></span><br><span class="line">块间公式</span><br><span class="line"><span class="variable">$</span><span class="variable">$</span></span><br></pre></td></tr></table></figure><h4 id="支持HTML"><a href="#支持HTML" class="headerlink" title="支持HTML"></a>支持HTML</h4><h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><blockquote><p>Typora 是一款轻便简洁的 Markdown 编辑器，支持即时渲染技术，这也是与其他Markdown编辑器最显著的区别。<br>即时渲染使得你写 Markdown 就像是写Word文档一样流畅自如。<br>个人认为是一款很好用的 MarkDown 编辑器，特来分享给大家❤️</p></blockquote><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p>阿里云：<a href="https://www.aliyundrive.com/s/mDzWKo9h3mB">https://www.aliyundrive.com/s/mDzWKo9h3mB</a></p><h3 id="支持正版"><a href="#支持正版" class="headerlink" title="支持正版"></a>支持正版</h3><p>以下内容引用自 <a href="https://www.cnblogs.com/xiaohi/p/15907083.html">Typora的下载和破解|博客园</a></p><blockquote><p>注意，该破解方法仅适用于 Typora 1.0.x 版本的破解，对于更高版本（如 Typora1.2.4）不适用。下载好 Typora 后可通过 帮助-关于 查看 Typora 版本。</p></blockquote><p>破解链接：<a href="https://www.cnblogs.com/hyacinthLJP/p/16123932.html">https://www.cnblogs.com/hyacinthLJP/p/16123932.html</a></p><h3 id="在Typora中书写MarkDown"><a href="#在Typora中书写MarkDown" class="headerlink" title="在Typora中书写MarkDown"></a>在Typora中书写MarkDown</h3><table><thead><tr><th align="center"></th><th align="left">Markdown语法</th><th align="center">Typora快捷键</th></tr></thead><tbody><tr><td align="center">一级标题</td><td align="left"><code>#</code></td><td align="center">ctrl+1</td></tr><tr><td align="center">二级标题</td><td align="left"><code>##</code></td><td align="center">ctrl+2</td></tr><tr><td align="center">三级标题</td><td align="left"><code>###</code></td><td align="center">ctrl+3</td></tr><tr><td align="center">四级标题</td><td align="left"><code>####</code></td><td align="center">ctrl+4</td></tr><tr><td align="center">五级标题</td><td align="left"><code>#####</code></td><td align="center">ctrl+5</td></tr><tr><td align="center">六级标题</td><td align="left"><code>######</code></td><td align="center">ctrl+6</td></tr><tr><td align="center">加粗</td><td align="left"><code>**粗体**</code></td><td align="center">ctrl+B</td></tr><tr><td align="center">斜体</td><td align="left"><code>*斜体*</code></td><td align="center">ctrl+I</td></tr><tr><td align="center">下划线</td><td align="left"><code>&lt;u&gt;下划线&lt;/u&gt;</code></td><td align="center">ctrl+U</td></tr><tr><td align="center">删除线</td><td align="left"><code>~~删除线~~</code></td><td align="center">alt+shift+5</td></tr><tr><td align="center">创建表格</td><td align="left"></td><td align="center">ctrl+T</td></tr><tr><td align="center">创建超链接</td><td align="left"><code>[超链接名](超链接地址)</code></td><td align="center">ctrl+K</td></tr><tr><td align="center">插入图片</td><td align="left"><code>![alt](图片地址)</code></td><td align="center">ctrl+shift+I</td></tr><tr><td align="center">插入公式块</td><td align="left"><code>$$公式$$</code></td><td align="center">ctrl+shift+M</td></tr><tr><td align="center">添加引用</td><td align="left"><code>&gt;内容</code></td><td align="center">ctrl+shift+Q</td></tr><tr><td align="center">无序列表</td><td align="left"><code>+ 内容</code></td><td align="center">ctrl+shift+]</td></tr><tr><td align="center">有序列表</td><td align="left"><code>1. 内容</code></td><td align="center">ctrl+shift+[</td></tr><tr><td align="center">粘贴为纯文本</td><td align="left"></td><td align="center">ctrl+shift+V</td></tr><tr><td align="center">返回Typora顶部</td><td align="left"></td><td align="center">ctrl+Home</td></tr><tr><td align="center">返回Typora底部</td><td align="left"></td><td align="center">ctrl+End</td></tr><tr><td align="center">启用&#x2F;退出 源代码模式</td><td align="left"></td><td align="center">ctrl+&#x2F;</td></tr><tr><td align="center">搜索</td><td align="left"></td><td align="center">ctrl+F</td></tr><tr><td align="center">搜索并替换</td><td align="left"></td><td align="center">ctrl+H</td></tr><tr><td align="center">选中光标所在行</td><td align="left"></td><td align="center">ctrl+L</td></tr><tr><td align="center">生成文档目录</td><td align="left"></td><td align="center"><code>[toc]</code>+Enter</td></tr><tr><td align="center">快速打开最新文档</td><td align="left"></td><td align="center">ctrl+P</td></tr></tbody></table><blockquote><p>TOC从文档中提取所有标题，其内容将自动更新。</p></blockquote><h3 id="图片插入"><a href="#图片插入" class="headerlink" title="图片插入"></a>图片插入</h3><p>插入图片除了使用插入语句外，还可以：</p><ul><li>ctrl+C&#x2F;V 将网络图片、剪贴板图片复制到文档中</li><li>拖动本地图片到文档中</li></ul><p>Typora 会自动帮你插入符合 Markdown 语法的图片语句，并给它添加<code>alt</code>。</p><h3 id="打字机模式和专注模式"><a href="#打字机模式和专注模式" class="headerlink" title="打字机模式和专注模式"></a>打字机模式和专注模式</h3><p>通过 视图→打字机模式&#x2F;专注模式 开启或关闭：</p><ul><li>「打字机模式」使得你所编辑的那一行永远处于屏幕正中央。</li><li>「专注模式」使你正在编辑的那一行保留颜色，而其他行的字体呈灰色。</li></ul><h3 id="空格与换行"><a href="#空格与换行" class="headerlink" title="空格与换行"></a>空格与换行</h3><ul><li><strong>空格：</strong>在输入连续的空格后，Typora 会在编辑器视图里为你保留这些空格，但当你打印或导出时，这些空格会被省略成一个。<br>你可以在源代码模式下，为每个空格前加一个 <code>\</code> 转义符，或者直接使用 HTML 风格的 <code>&amp;nbps;</code> 来保持连续的空格。</li></ul><blockquote><p>需要说明的是，在 Markdown 语法中，换行（line break）与换段是不同的，且换行分为软换行和硬换行。</p></blockquote><ul><li><strong>软换行</strong>：在 Typora 中，你可以通过shift+enter完成一次软换行。软换行只在编辑界面可见，当文档被导出时换行会被省略。</li><li><strong>硬换行：</strong>你可以通过 空格+ 空格+ shift+enter完成一次硬换行，而这也是许多 Markdown 编辑器所原生支持的。硬换行在文档被导出时将被保留，且没有换段的段后距。</li><li><strong>换段：</strong>你可以通过enter完成一次换段。Typora 会自动帮你完成两次shift+enter的软换行，从而完成一次换段。这也意味着在 Markdown 语法下，换段是通过在段与段之间加入空行来实现的。</li><li><strong>Windows 风格（CR+LF）与 Unix 风格（LF）的换行符：</strong>CR表示回车<code>\r</code>，即回到一行的开头，而LF表示换行<code>\n</code>，即另起一行。<br>所以 Windows 风格的换行符本质是「回车+换行」，而 Unix 风格的换行符是「换行」。这也是为什么 Unix&#x2F;Mac 系统下的文件，如果在 Windows 系统直接打开会全部在同一行内。你可以在「文件 - 偏好设置 - 编辑器 - 默认换行符」中对此进行切换。</li></ul><h3 id="支持emoji-表情"><a href="#支持emoji-表情" class="headerlink" title="支持emoji 表情"></a>支持emoji 表情</h3><p>在 Typora 中，你可以用 <code>:emoji:</code> 的形式来打出 emoji，软件会自动给出图形的提示。</p><h3 id="Little-Tips"><a href="#Little-Tips" class="headerlink" title="Little Tips"></a>Little Tips</h3><p>安利一个快捷键提示工具，轻量级+快捷方便。<br>官网：<a href="http://www.redisant.cn/ltip">LittleTips</a><br>它本身支持的软件列表并不包含Typora，但给出了 <a href="http://www.redisant.cn/ltip/newapp">自定义软件快捷键</a> 的方式，所以，我就自己捣鼓了一下：</p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/202204101206876.png" style="zoom: 67%;" /><p>自行选择下载：<a href="https://www.aliyundrive.com/s/WjQsc88Xf7q">typora.json</a>。 LittleTips不含开机自启的选项，如果你想要设置成开机自启，可参考如下方法：</p><ol><li>将需要自启动软件创建一个快捷方式</li><li>按 win+ R，键入<code>shell:startup</code>，打开 「启动」 文件夹</li><li>将需要开机自启动的软件的快捷方式拖到启动文件夹中</li></ol><h3 id="Typora设置图片自动上传"><a href="#Typora设置图片自动上传" class="headerlink" title="Typora设置图片自动上传"></a>Typora设置图片自动上传</h3><blockquote><p>Typora固然好用，MarkDown也固然好用，但图片该怎么处理？<br>总不能自己一张张的上传，然后在复制网络连接吧，也不是不可以🤔</p></blockquote><p>下面介绍两种方式实现自动上传。</p><h4 id="使用-PicGo-Core"><a href="#使用-PicGo-Core" class="headerlink" title="使用 PicGo-Core"></a>使用 PicGo-Core</h4><p>下载 PicGo-Core</p><ul><li>依次点击 <strong>文件</strong> -&gt; <strong>偏好设置</strong> -&gt; <strong>图像</strong> 来到下图所示界面：</li></ul><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/202204101207252.png" style="zoom: 67%;" /><p>+ 点击<strong>①</strong>位置选择 <code>PicGo-Gore(command line)</code>选项后，点击<strong>②</strong>位置的下载或更新，在弹出的界面中选择下载。</p><p>选择sm.ms作为图床并配置 token</p><blockquote><p>免费版存储容量 5GB，每分钟限制上传20张，每小时限制上传100张，每天限制上传200张，每周限制上传500张，每月限制上传1000张，单张图片最大5M。<br>该图床建立于2015年，目前免费用户无法使用香港节点因此速度比较慢（白嫖党没这么多事）。</p></blockquote><ol><li><p>打开官网 <a href="https://sm.ms/%EF%BC%8C%E6%B3%A8%E5%86%8C%E5%90%8E%E7%99%BB%E5%BD%95%E3%80%82">https://sm.ms/，注册后登录。</a></p></li><li><p>打开该网址 <a href="https://sm.ms/home/apitoken%EF%BC%8C%E7%94%9F%E6%88%90">https://sm.ms/home/apitoken，生成</a> token。</p></li><li><p>最后点击<strong>③</strong>位置配置 token，放置如下代码：</p></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;picBed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;uploader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;smms&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;smms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xxxxxxxxxxxxxxxxxxxxxx&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;picgoPlugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>token 换成刚刚生成的 sm.ms 的token。</p></blockquote><ol><li>按照步骤配置好后，点击验证图片上传选项，如果提示验证成功，那么恭喜，你毕业了🎊；</li><li>拖拽图片到 typora 实现自动上传并更改 url 的功能。</li></ol><h4 id="使用-PicGo-Gitee"><a href="#使用-PicGo-Gitee" class="headerlink" title="使用 PicGo+Gitee"></a>使用 PicGo+Gitee</h4><p>安装 Node.js</p><blockquote><p>因为PicGo中默认不支持 gitee，所以我们需要安装<code>Node.js</code>插件。</p></blockquote><p>下载地址：</p><ul><li>阿里云：<a href="https://www.aliyundrive.com/s/W18SWY8Ti8X">https://www.aliyundrive.com/s/W18SWY8Ti8X</a></li><li>官网：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></li></ul><p>安装步骤：</p><ol><li><p>双击&#96;&#96;node-v16.14.2-x64.msi&#96;进行安装。</p></li><li><p>自定义安装路径</p></li><li><p>注意：不要勾选附加选项</p></li></ol><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/202204101311191.png" style="zoom: 80%;" /><ol start="4"><li>安装完成记得<strong>重启电脑</strong>。</li></ol><p>Gitee相关</p><ol><li><p>打开 Gitee（官网：<a href="https://gitee.com/%EF%BC%89%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E8%B4%A6%E6%88%B7%EF%BC%8C%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E3%80%82">https://gitee.com/），如果没有账户，新建一个。</a></p></li><li><p>新建仓库</p></li><li><p>仓库开源设置</p></li><li><p>生成私人令牌</p></li></ol><blockquote><p>注意保存好私人令牌的序列号，该令牌只显示这一次。<br>如果你不幸忘记了该令牌，那就是好重新生成一个了🐤。</p></blockquote><p>安装 PicGo</p><p>下载地址：</p><ul><li>阿里云：<a href="https://www.aliyundrive.com/s/GjNGu1SGur1">https://www.aliyundrive.com/s/GjNGu1SGur1</a></li><li>官网：<a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></li></ul><blockquote><p>在官网上下载要选择正式稳定的版本。</p></blockquote><p> 安装步骤：</p><ol><li><p>双击<code>PicGo-Setup-2.3.0-x64.exe</code>进行安装。</p></li><li><p>自定义安装路径</p></li><li><p>插件安装，选择<code>github-plus</code>或者<code>gitee-uploader</code>，二者择其一即可，我选择的是<code>git-plus</code>。</p></li><li><p>配置 gitee，并设置为默认图床：</p></li></ol><p>&gt; token放置上述过程生成的序列号即可</p><ol start="5"><li>重启 PicGO 软件（关闭后重新打开）。</li></ol><p>Typora配置</p><p>重新打开 Typora，选择 文件-&gt;偏好设置-&gt;图像：</p><p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/202204222123169.png"></p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>注意事项</p><ol><li>自定义的HTML中的图片无法上传</li><li>PicGo最好设置上「时间戳重命名」，防止上传同名文件时报错</li></ol><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/202204222123813.png" style="zoom:67%;" /><ol start="3"><li>使用「上传所有本地图片」可能会出现图片顺序错乱的情况，所以还是建议单张上传</li></ol><blockquote><p>TinyPNG</p></blockquote><p>既然提到了图床，那就顺带安利一个图片压缩工具：</p><ul><li>在线压缩：<a href="https://tinypng.com/">TinyPNG – Compress WebP, PNG and JPEG images intelligently</a></li><li>可视化工具：<a href="https://download.redisant.com/package/TinyGUI-1.0.5.0.exe">https://download.redisant.com/package/TinyGUI-1.0.5.0.exe</a></li><li>GitHub地址：<a href="https://github.com/chenjing1294/TinyGUI/tree/main/TinyGUI">TinyGUI&#x2F;TinyGUI at main · chenjing1294&#x2F;TinyGUI · GitHub</a></li></ul><blockquote><p>如果使用TinyGUI可视化工具，在获取API的时候，若长时间未收到反馈邮件，去垃圾邮件看看，会有意想不到的收货💨</p></blockquote><p><strong>转至：</strong><a href="https://www.cnblogs.com/hyacinthLJP/p/16123932.html">https://www.cnblogs.com/hyacinthLJP/p/16123932.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大排序</title>
      <link href="/2022/04/22/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/04/22/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>以下介绍的内容来自《算法 4》和《算法导论》，它们介绍的算法思想足够经典，但不是最新研究结果，也并非最快。如果想研究最新排序算法的结论，可以参考最新的学术论文，或者是在互联网上搜索相关资料，或者是查看您当前所使用语言关于排序部分的源代码。</p><h3 id="选择排序（了解）"><a href="#选择排序（了解）" class="headerlink" title="选择排序（了解）"></a>选择排序（了解）</h3><p>思路：每一轮选取未排定的部分中<code>最小</code>的部分交换到未排定部分的最开头，经过若干个步骤，就能排定整个数组。即：先选出最小的，再选出第 2 小的，以此类推。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择排序：每一轮选择最小元素交换到未排定部分的开头</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 循环不变量：[0, i) 有序，且该区间里所有元素就是最终排定的样子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 选择区间 [i, len - 1] 里最小的元素的索引，交换到下标 i</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[minIndex]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        <span class="type">int</span>[] res = solution.sortArray(nums);</span><br><span class="line">        System.out.println(Arrays.toString(res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>总结：</code></p><ul><li><p>算法思想 1：贪心算法：每一次决策只看当前，当前最优，则全局最优。注意：这种思想不是任何时候都适用。</p></li><li><p>算法思想 2：减治思想：外层循环每一次都能排定一个元素，问题的规模逐渐减少，直到全部解决，即「大而化小，小而化了」。运用「减治思想」很典型的算法就是大名鼎鼎的「二分查找」。</p></li><li><p>优点：交换次数最少。</p></li></ul><p>「选择排序」看起来好像最没有用，但是如果在交换成本较高的排序任务中，就可以使用「选择排序」（《算法 4》相关章节课后练习题）。</p><p>依然是建议大家不要对算法带有个人色彩，在面试回答问题的时候和看待一个人和事物的时候，可以参考的回答模式是「具体问题具体分析，在什么什么情况下，用什么什么算法」。</p><p><code>复杂度分析：</code></p><ul><li>时间复杂度：O(N^2)，这里 N 是数组的长度；</li><li>空间复杂度：O(1)，使用到常数个临时变量。</li></ul><h3 id="插入排序（熟悉）"><a href="#插入排序（熟悉）" class="headerlink" title="插入排序（熟悉）"></a>插入排序（熟悉）</h3><p>思路：每次将一个数字插入一个有序的数组里，成为一个长度更长的有序数组，有限次操作以后，数组整体有序。</p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/710dd138492c0da4324657033971f3bee0355514f2ab2834756c988a90398cbb-file_1585624920301.gif" style="zoom:80%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入排序：稳定排序，在接近有序的情况下，表现优异</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 循环不变量：将 nums[i] 插入到区间 [0, i) 使之成为有序数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 先暂存这个元素，然后之前元素逐个后移，留出空位</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">// 注意边界 j &gt; 0</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; nums[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">                nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>优化：「将一个数字插入一个有序的数组」这一步，可以不使用逐步交换，使用先赋值给「临时变量」，然后「适当的元素」后移，空出一个位置，最后把「临时变量」赋值给这个空位的策略（就是上面那张图的意思）。编码的时候如果不小心，可能会把数组的值修改，建议多调试；</p></li><li><p>特点：「插入排序」可以提前终止内层循环（体现在 nums[j - 1] &gt; temp 不满足时），在数组「几乎有序」的前提下，「插入排序」的时间复杂度可以达到 O(N)；</p></li><li><p>由于「插入排序」在「几乎有序」的数组上表现良好，特别地，在「短数组」上的表现也很好。因为「短数组」的特点是：每个元素离它最终排定的位置都不会太远。为此，在小区间内执行排序任务的时候，可以转向使用「插入排序」。</p></li></ul><p><code>复杂度分析：</code></p><ul><li>时间复杂度：O(N^2)，这里 N 是数组的长度；</li><li>空间复杂度：O(1)，使用到常数个临时变量</li></ul><h3 id="归并排序（重点）"><a href="#归并排序（重点）" class="headerlink" title="归并排序（重点）"></a>归并排序（重点）</h3><ul><li>基本思路：借助额外空间，合并两个有序数组，得到更长的有序数组。例如：「力扣」第 88 题：合并两个有序数组。</li><li>算法思想：分而治之（分治思想）。「分而治之」思想的形象理解是「曹冲称象」、MapReduce，在一定情况下可以并行化。</li><li>个人建议：「归并排序」是理解「递归思想」的非常好的学习材料，大家可以通过理解：递归完成以后，合并两个有序数组的这一步骤，想清楚程序的执行流程。即「递归函数执行完成以后，我们还可以做点事情」。因此，「归并排序」我个人觉得非常重要，一定要掌握。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 归并排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 列表大小等于或小于该大小，将优先于 mergeSort 使用插入排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INSERTION_SORT_THRESHOLD</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, len - <span class="number">1</span>, temp);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组 nums 的子区间 [left, right] 进行归并排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp  用于合并两个有序数组的辅助数组，全局使用一份，避免多次创建和销毁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="comment">// 小区间使用插入排序</span></span><br><span class="line">        <span class="keyword">if</span> (right - left &lt;= INSERTION_SORT_THRESHOLD) &#123;</span><br><span class="line">            insertionSort(nums, left, right);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// Java 里有更优的写法，在 left 和 right 都是大整数时，即使溢出，结论依然正确</span></span><br><span class="line">        <span class="comment">// int mid = (left + right) &gt;&gt;&gt; 1;</span></span><br><span class="line"></span><br><span class="line">        mergeSort(nums, left, mid, temp);</span><br><span class="line">        mergeSort(nums, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">        <span class="comment">// 如果数组的这个子区间本身有序，无需合并</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mergeOfTwoSortedArray(nums, left, mid, right, temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组 arr 的子区间 [left, right] 使用插入排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr   给定数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  左边界，能取到</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边界，能取到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; left &amp;&amp; arr[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并两个有序数组：先把值复制到临时数组，再合并回去</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mid   [left, mid] 有序，[mid + 1, right] 有序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp  全局使用的临时数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeOfTwoSortedArray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        System.arraycopy(nums, left, temp, left, right + <span class="number">1</span> - left);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> left; k &lt;= right; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == mid + <span class="number">1</span>) &#123;</span><br><span class="line">                nums[k] = temp[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == right + <span class="number">1</span>) &#123;</span><br><span class="line">                nums[k] = temp[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp[i] &lt;= temp[j]) &#123;</span><br><span class="line">                <span class="comment">// 注意写成 &lt; 就丢失了稳定性（相同元素原来靠前的排序以后依然靠前）</span></span><br><span class="line">                nums[k] = temp[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// temp[i] &gt; temp[j]</span></span><br><span class="line">                nums[k] = temp[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优化 1：在「小区间」里转向使用「插入排序」，Java 源码里面也有类似这种操作，「小区间」的长度是个超参数，需要测试决定，我这里参考了 JDK 源码；</li><li>优化 2： 在「两个数组」本身就是有序的情况下，无需合并；</li><li>优化 3：全程使用一份临时数组进行「合并两个有序数组」的操作，避免创建临时数组和销毁的消耗，避免计算下标偏移量。<br>注意：实现归并排序的时候，要特别注意，不要把这个算法实现成非稳定排序，区别就在 &lt;&#x3D; 和 &lt; ，已在代码中注明。</li></ul><p>「归并排序」比「快速排序」好的一点是，<code>它借助了额外空间</code>，可以实现「稳定排序」，Java 里对于「对象数组」的排序任务，就是使用归并排序的升级版 TimSort，在这里就不多做介绍）。</p><p><code>复杂度分析：</code></p><ul><li>时间复杂度：O(N log N)，这里 N 是数组的长度；</li><li>空间复杂度：O(N)，辅助数组与输入数组规模相当。</li></ul><p>「归并排序」也有「原地归并排序」和「不使用递归」的归并排序，但是我个人觉得不常用，编码、调试都有一定难度。<code>递归、分治处理问题的思想在基础算法领域是非常常见的，建议多练习编写「归并排序」学习递归思想，了解递归的细节，熟悉分治的思想。</code></p><h3 id="快速排序（重点）"><a href="#快速排序（重点）" class="headerlink" title="快速排序（重点）"></a>快速排序（重点）</h3><ul><li><p>基本思路：快速排序每一次都排定一个元素（这个元素呆在了它最终应该呆的位置），然后递归地去排它左边的部分和右边的部分，依次进行下去，直到数组有序；</p></li><li><p>算法思想：分而治之（分治思想），与「归并排序」不同，「快速排序」在「分」这件事情上不想「归并排序」无脑地一分为二，而是采用了 partition 的方法（书上，和网上都有介绍，就不展开了），因此就没有「合」的过程。</p></li><li><p>实现细节（注意事项）：（针对特殊测试用例：顺序数组或者逆序数组）一定要随机化选择切分元素（pivot），否则在输入数组是有序数组或者是逆序数组的时候，快速排序会变得非常慢（等同于冒泡排序或者「选择排序」）；</p></li></ul><p>以下是针对特殊测试用例（有很多重复元素的输入数组）有 3 种版本：</p><ul><li>版本 1：基本：把等于切分元素的所有元素分到了数组的同一侧，可能会造成递归树倾斜；</li><li>版本 2：双指针：把等于切分元素的所有元素等概率地分到了数组的两侧，避免了递归树倾斜，递归树相对平衡；</li><li>版本 3：三指针：把等于切分元素的所有元素挤到了数组的中间，在有很多元素和切分元素相等的情况下，递归区间大大减少。</li></ul><p>这里有一个经验的总结：之所以有这些优化，起因都是来自「递归树」的高度。关于「树」的算法的优化，绝大部分都是在和树的「高度」较劲。类似的通过减少树高度、使得树更平衡的数据结构还有「二叉搜索树」优化成「AVL 树」或者「红黑树」、「并查集」的「按秩合并」与「路径压缩」。</p><ul><li>写对「快速排序」的技巧：保持「循环不变量」，即定义的变量在循环开始前、循环过程中、循环结束以后，都保持不变的性质，这个性质是人为根据问题特点定义的。</li><li>「循环不变量」的内容在《算法导论》这本书里有介绍。我个人觉得非常有用。「循环不变量」是证明算法有效性的基础，更是写对代码的保证，遵守循环不变量，是不是该写等于号，先交换还是先 ++ ，就会特别清楚，绝对不会写错，我在编码的时候，会将遵守的「循环不变量」作为注释写在代码中。</li></ul><p>快速排序丢失了稳定性，如果需要稳定的快速排序，需要具体定义比较函数，这个过程叫「稳定化」，在这里就不展开了。</p><p>说明：</p><ul><li>lt 是 less than 的缩写，表示（严格）小于；</li><li>gt 是 greater than 的缩写，表示（严格）大于；</li><li>le 是 less than or equal 的缩写，表示小于等于（本代码没有用到）；</li><li>ge 是 greater than or equal 的缩写，表示大于等于（本代码没有用到）。</li></ul><blockquote><p>版本一</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速排序 1：基本快速排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 列表大小等于或小于该大小，将优先于 quickSort 使用插入排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INSERTION_SORT_THRESHOLD</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">RANDOM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 小区间使用插入排序</span></span><br><span class="line">        <span class="keyword">if</span> (right - left &lt;= INSERTION_SORT_THRESHOLD) &#123;</span><br><span class="line">            insertionSort(nums, left, right);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">pIndex</span> <span class="operator">=</span> partition(nums, left, right);</span><br><span class="line">        quickSort(nums, left, pIndex - <span class="number">1</span>);</span><br><span class="line">        quickSort(nums, pIndex + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组 nums 的子区间 [left, right] 使用插入排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums  给定数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  左边界，能取到</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边界，能取到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; left &amp;&amp; nums[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">                nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> RANDOM.nextInt(right - left + <span class="number">1</span>) + left;</span><br><span class="line">        swap(nums, left, randomIndex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基准值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">lt</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">// 循环不变量：</span></span><br><span class="line">        <span class="comment">// all in [left + 1, lt] &lt; pivot</span></span><br><span class="line">        <span class="comment">// all in [lt + 1, i) &gt;= pivot</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; pivot) &#123;</span><br><span class="line">                lt++;</span><br><span class="line">                swap(nums, i, lt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, left, lt);</span><br><span class="line">        <span class="keyword">return</span> lt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>版本二</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速排序 2：双指针（指针对撞）快速排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 列表大小等于或小于该大小，将优先于 quickSort 使用插入排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INSERTION_SORT_THRESHOLD</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">RANDOM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 小区间使用插入排序</span></span><br><span class="line">        <span class="keyword">if</span> (right - left &lt;= INSERTION_SORT_THRESHOLD) &#123;</span><br><span class="line">            insertionSort(nums, left, right);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">pIndex</span> <span class="operator">=</span> partition(nums, left, right);</span><br><span class="line">        quickSort(nums, left, pIndex - <span class="number">1</span>);</span><br><span class="line">        quickSort(nums, pIndex + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组 nums 的子区间 [left, right] 使用插入排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums  给定数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  左边界，能取到</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边界，能取到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; left &amp;&amp; nums[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">                nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> left + RANDOM.nextInt(right - left + <span class="number">1</span>);</span><br><span class="line">        swap(nums, randomIndex, left);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">lt</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">gt</span> <span class="operator">=</span> right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环不变量：</span></span><br><span class="line">        <span class="comment">// all in [left + 1, lt) &lt;= pivot</span></span><br><span class="line">        <span class="comment">// all in (gt, right] &gt;= pivot</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (lt &lt;= right &amp;&amp; nums[lt] &lt; pivot) &#123;</span><br><span class="line">                lt++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (gt &gt; left &amp;&amp; nums[gt] &gt; pivot) &#123;</span><br><span class="line">                gt--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (lt &gt;= gt) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 细节：相等的元素通过交换，等概率分到数组的两边</span></span><br><span class="line">            swap(nums, lt, gt);</span><br><span class="line">            lt++;</span><br><span class="line">            gt--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, left, gt);</span><br><span class="line">        <span class="keyword">return</span> gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>版本三</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速排序 3：三指针快速排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 列表大小等于或小于该大小，将优先于 quickSort 使用插入排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INSERTION_SORT_THRESHOLD</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">RANDOM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 小区间使用插入排序</span></span><br><span class="line">        <span class="keyword">if</span> (right - left &lt;= INSERTION_SORT_THRESHOLD) &#123;</span><br><span class="line">            insertionSort(nums, left, right);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> left + RANDOM.nextInt(right - left + <span class="number">1</span>);</span><br><span class="line">        swap(nums, randomIndex, left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环不变量：</span></span><br><span class="line">        <span class="comment">// all in [left + 1, lt] &lt; pivot</span></span><br><span class="line">        <span class="comment">// all in [lt + 1, i) = pivot</span></span><br><span class="line">        <span class="comment">// all in [gt, right] &gt; pivot</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">lt</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">gt</span> <span class="operator">=</span> right + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; gt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; pivot) &#123;</span><br><span class="line">                lt++;</span><br><span class="line">                swap(nums, i, lt);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                gt--;</span><br><span class="line">                swap(nums, i, gt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, left, lt);</span><br><span class="line">        <span class="comment">// 注意这里，大大减少了两侧分治的区间</span></span><br><span class="line">        quickSort(nums, left, lt - <span class="number">1</span>);</span><br><span class="line">        quickSort(nums, gt, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组 nums 的子区间 [left, right] 使用插入排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums  给定数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  左边界，能取到</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边界，能取到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; left &amp;&amp; nums[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">                nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>复杂度分析：</code></p><ul><li>时间复杂度：O(N log N)，这里 N 是数组的长度；</li><li>空间复杂度：O(log N)，这里占用的空间主要来自递归函数的栈空间。</li></ul><h3 id="堆排序（熟悉）"><a href="#堆排序（熟悉）" class="headerlink" title="堆排序（熟悉）"></a>堆排序（熟悉）</h3><p>堆讲的最好的资料就是《算法 4》，堆的内容比较多，我在这里就不多展开了，建议大家直接看书获得相关知识。</p><ul><li>堆排序是选择排序的优化，选择排序需要在未排定的部分里通过「打擂台」的方式选出最大的元素（复杂度 O(N)），而「堆排序」就把未排定的部分构建成一个「堆」，这样就能以 O(logN) 的方式选出最大元素；</li><li>堆是一种相当有意思的数据结构，它在很多语言里也被命名为「优先队列」。它是建立在数组上的「树」结构，类似的数据结构还有「并查集」「线段树」等。</li></ul><p>我个人是这样看待这些定义的：「优先队列」是一种特殊的队列，按照优先级顺序出队，从这一点上说，与「普通队列」无差别。「优先队列」可以用数组实现，也可以用有序数组实现，但只要是线性结构，复杂度就会高，因此，「树」结构就有优势，「优先队列」的最好实现就是「堆」。</p><p>「堆」还有很多扩展的知识：「索引堆」、「多叉堆」，已经不在我能介绍的范围了，我个人觉得一般的面试问题也不会涉及。但是基础的堆的相关知识是有必要掌握的，要知道堆的底层是数组，可能涉及扩容的问题，上浮和下沉操作。</p><p>「力扣」上有很多使用「优先队列」完成的问题，感兴趣的朋友不妨做一下。</p><p>至于现在笔试考不考「手写一个堆」，我个人觉得意义不大。如果真的考到了，能写尽量写，不能一次写对就和面试官说明自己对于「堆」所掌握的知识我感觉就可以了。面试的时候，本来精神就比平常紧张。我们都不是「堆」的发明人，了解和熟悉「堆」的原理和使用场景，自己学习的时候，手写过堆，通过了测试用例就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 将数组整理成堆</span></span><br><span class="line">        heapify(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环不变量：区间 [0, i] 堆有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt;= <span class="number">1</span>; ) &#123;</span><br><span class="line">            <span class="comment">// 把堆顶元素（当前最大）交换到数组末尾</span></span><br><span class="line">            swap(nums, <span class="number">0</span>, i);</span><br><span class="line">            <span class="comment">// 逐步减少堆有序的部分</span></span><br><span class="line">            i--;</span><br><span class="line">            <span class="comment">// 下标 0 位置下沉操作，使得区间 [0, i] 堆有序</span></span><br><span class="line">            siftDown(nums, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数组整理成堆（堆有序）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 只需要从 i = (len - 1) / 2 这个位置开始逐层下移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (len - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            siftDown(nums, i, len - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k    当前下沉元素的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end  [0, end] 是 nums 的有效部分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt;= end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= end &amp;&amp; nums[j + <span class="number">1</span>] &gt; nums[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[k]) &#123;</span><br><span class="line">                swap(nums, j, k);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>复杂度分析：</code></p><ul><li>时间复杂度：O(N log N)，这里 N是数组的长度；</li><li>空间复杂度：O(1)。</li></ul><h3 id="希尔排序（了解）"><a href="#希尔排序（了解）" class="headerlink" title="希尔排序（了解）"></a>希尔排序（了解）</h3><p>希尔排序的参考资料是《算法 4》。</p><p>思想来源：插入排序的优化。在插入排序里，如果靠后的数字较小，它来到前面就得交换多次。「希尔排序」改进了这种做法。带间隔地使用插入排序，直到最后「间隔」为 11 的时候，就是标准的「插入排序」，此时数组里的元素已经「几乎有序」了；<br>希尔排序的「间隔序列」其实是一个超参数，这方面有一些研究成果，有兴趣的朋友可以了解一下，但是如果这是面向笔试面试，就不用了解了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 希尔排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 Knuth 增量序列</span></span><br><span class="line">        <span class="comment">// 找增量的最大值</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">3</span> * h + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">            h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// insertion sort</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h; i &lt; len; i++) &#123;</span><br><span class="line">                insertionForDelta(nums, h, i);</span><br><span class="line">            &#125;</span><br><span class="line">            h = h / <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 nums[i] 插入到对应分组的正确位置上，其实就是将原来 1 的部分改成 gap</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> gap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertionForDelta</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> gap, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="comment">// 注意：这里 j &gt;= deta 的原因</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= gap &amp;&amp; nums[j - gap] &gt; temp) &#123;</span><br><span class="line">            nums[j] = nums[j - gap];</span><br><span class="line">            j -= gap;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>希尔排序的时间复杂度至今还没有明确的结论，只有一个范围，已经不在我能介绍的范围了。</p><h3 id="冒泡排序（了解）"><a href="#冒泡排序（了解）" class="headerlink" title="冒泡排序（了解）"></a>冒泡排序（了解）</h3><ul><li>基本思想：外层循环每一次经过两两比较，把每一轮未排定部分最大的元素放到了数组的末尾；</li><li>「冒泡排序」有个特点：在遍历的过程中，提前检测到数组是有序的，从而结束排序，而不像「选择排序」那样，即使输入数据是有序的，「选择排序」依然需要「傻乎乎」地走完所有的流程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 冒泡排序：超时</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 先默认数组是有序的，只要发生一次交换，就必须进行下一轮比较，</span></span><br><span class="line">            <span class="comment">// 如果在内层循环中，都没有执行一次交换操作，说明此时数组已经是升序数组</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">sorted</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(nums, j, j + <span class="number">1</span>);</span><br><span class="line">                    sorted = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sorted) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>复杂度分析：</code></p><ul><li>时间复杂度：O(N^2)，这里 N是数组的长度；</li><li>空间复杂度：O(1)，使用到常数个临时变量。</li></ul><p><code>3 种「非比较」的排序算法（了解，如果是面向笔试，不要花时间去研究）</code><br>特别说明：这部分算法不建议花太多去仔细研究它们的细节。如果是面向面试，了解思想即可，用到了再学。</p><p>直接放弃我个人觉得完全可以。</p><p>学习资料是《算法导论》。下面是我根据《算法导论》上介绍的内容整理出来的。</p><p>这三种排序的区别与上面的排序的特点是：一个数该放在哪里，是由这个数本身的大小决定的，它不需要经过比较。也可以认为是哈希的思想：由数值映射地址。</p><p>因此这三种算法一定需要额外的空间才能完成排序任务，时间复杂度可以提升到 O(N)，但适用场景不多，主要是因为使用这三种排序一定要保证输入数组的每个元素都在一个合理的范围内。</p><p>这三种算法还有一个特点是：都可以实现成稳定排序，无需稳定化。</p><p>我在这里只是给出了可以通过测评的代码，没有具体展开介绍了。具体想知道细节的朋友可以参考《算法导论》。</p><h3 id="计数排序（了解）"><a href="#计数排序（了解）" class="headerlink" title="计数排序（了解）"></a>计数排序（了解）</h3><p>「计数排序」是这三种排序算法里最好理解的，从名字就可以看出。把每个出现的数值都做一个计数，然后根据计数从小到大输出得到有序数组。</p><p>这种做法丢失了稳定性，如果是本题这种基本数据类型的话没有关系。如果是对象类型，就不能这么做了。</p><p>保持稳定性的做法是：先对计数数组做前缀和，在第 2 步往回赋值的时候，根据原始输入数组的数据从后向前赋值，前缀和数组保存了每个元素存放的下标信息（这里没有说得太细，本来这一点就不重要，也不难理解）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OFFSET</span> <span class="operator">=</span> <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 由于 -50000 &lt;= A[i] &lt;= 50000</span></span><br><span class="line">        <span class="comment">// 因此&quot;桶&quot; 的大小为 50000 - (-50000) = 10_0000</span></span><br><span class="line">        <span class="comment">// 并且设置偏移 OFFSET = 50000，目的是让每一个数都能够大于等于 0</span></span><br><span class="line">        <span class="comment">// 这样就可以作为 count 数组的下标，查询这个数的计数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">10_0000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计数数组</span></span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="comment">// 计算计数数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            count[num + OFFSET]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把 count 数组变成前缀和数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先把原始数组赋值到一个临时数组里，然后回写数据</span></span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        System.arraycopy(nums, <span class="number">0</span>, temp, <span class="number">0</span>, len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了保证稳定性，从后向前赋值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> count[temp[i] + OFFSET] - <span class="number">1</span>;</span><br><span class="line">            nums[index] = temp[i];</span><br><span class="line">            count[temp[i] + OFFSET]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：（略，这部分内容不太重要，增加学习负担）</p><h3 id="基数排序（了解）"><a href="#基数排序（了解）" class="headerlink" title="基数排序（了解）"></a>基数排序（了解）</h3><ul><li><p>基本思路：也称为基于关键字的排序，例如针对数值排序，个位、十位、百位就是关键字。针对日期数据的排序：年、月、日、时、分、秒就是关键字。</p></li><li><p>「基数排序」用到了「计数排序」。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基数排序：低位优先</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OFFSET</span> <span class="operator">=</span> <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预处理，让所有的数都大于等于 0，这样才可以使用基数排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            nums[i] += OFFSET;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 1 步：找出最大的数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; max) &#123;</span><br><span class="line">                max = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 2 步：计算出最大的数字有几位，这个数值决定了我们要将整个数组看几遍</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> getMaxLen(max);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计数排序需要使用的计数数组和临时数组</span></span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 表征关键字的量：除数</span></span><br><span class="line">        <span class="comment">// 1 表示按照个位关键字排序</span></span><br><span class="line">        <span class="comment">// 10 表示按照十位关键字排序</span></span><br><span class="line">        <span class="comment">// 100 表示按照百位关键字排序</span></span><br><span class="line">        <span class="comment">// 1000 表示按照千位关键字排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">divisor</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 有几位数，外层循环就得执行几次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxLen; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每一步都使用计数排序，保证排序结果是稳定的</span></span><br><span class="line">            <span class="comment">// 这一步需要额外空间保存结果集，因此把结果保存在 temp 中</span></span><br><span class="line">            countingSort(nums, temp, divisor, len, count);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 交换 nums 和 temp 的引用，下一轮还是按照 nums 做计数排序</span></span><br><span class="line">            <span class="type">int</span>[] t = nums;</span><br><span class="line">            nums = temp;</span><br><span class="line">            temp = t;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// divisor 自增，表示采用低位优先的基数排序</span></span><br><span class="line">            divisor *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            res[i] = nums[i] - OFFSET;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span>[] res, <span class="type">int</span> divisor, <span class="type">int</span> len, <span class="type">int</span>[] count)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、计算计数数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 计算数位上的数是几，先取个位，再十位、百位</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> (nums[i] / divisor) % <span class="number">10</span>;</span><br><span class="line">            count[remainder]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、变成前缀和数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、从后向前赋值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> (nums[i] / divisor) % <span class="number">10</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> count[remainder] - <span class="number">1</span>;</span><br><span class="line">            res[index] = nums[i];</span><br><span class="line">            count[remainder]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、count 数组需要设置为 0 ，以免干扰下一次排序使用</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            count[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取一个整数的最大位数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxLen</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">            maxLen++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：（略，这部分内容不太重要，增加学习负担）</p><h3 id="桶排序（了解）"><a href="#桶排序（了解）" class="headerlink" title="桶排序（了解）"></a>桶排序（了解）</h3><ul><li>基本思路：一个坑一个萝卜，也可以一个坑多个萝卜，对每个坑排序，再拿出来，整体就有序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 桶排序</span></span><br><span class="line">    <span class="comment">// 1 &lt;= A.length &lt;= 10000</span></span><br><span class="line">    <span class="comment">// -50000 &lt;= A[i] &lt;= 50000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10_0000</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OFFSET</span> <span class="operator">=</span> <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 第 1 步：将数据转换为 [0, 10_0000] 区间里的数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            nums[i] += OFFSET;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 2 步：观察数据，设置桶的个数</span></span><br><span class="line">        <span class="comment">// 步长：步长如果设置成 10 会超出内存限制</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 桶的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bucketLen</span> <span class="operator">=</span> <span class="number">10_0000</span> / step;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] temp = <span class="keyword">new</span> <span class="title class_">int</span>[bucketLen + <span class="number">1</span>][len];</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[bucketLen + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 3 步：分桶</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">bucketIndex</span> <span class="operator">=</span> num / step;</span><br><span class="line">            temp[bucketIndex][next[bucketIndex]] = num;</span><br><span class="line">            next[bucketIndex]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 4 步：对于每个桶执行插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucketLen + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            insertionSort(temp[i], next[i] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 5 步：从桶里依次取出来</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucketLen + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curLen</span> <span class="operator">=</span> next[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; curLen; j++) &#123;</span><br><span class="line">                res[index] = temp[i][j] - OFFSET;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= endIndex; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：（略，这部分内容不太重要，增加学习负担）</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针(本质原理)</title>
      <link href="/2022/04/21/%E5%8F%8C%E6%8C%87%E9%92%88%E6%9C%AC%E8%B4%A8%E5%8E%9F%E7%90%86/"/>
      <url>/2022/04/21/%E5%8F%8C%E6%8C%87%E9%92%88%E6%9C%AC%E8%B4%A8%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="双指针-本质原理"><a href="#双指针-本质原理" class="headerlink" title="双指针(本质原理)"></a>双指针(本质原理)</h3><p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/image-20220421150343060.png" alt="image-20220421150343060"></p><p>很多题解只给出了双指针解法的代码，但没有说明解法的正确性。为什么双指针往中间移动时，不会漏掉某些情况呢？要解答这个问题，我们要从<code>缩减搜索空间的角度</code>思考这个解法。下面我将以文字和图片两种方式进行讲解。</p><p>首先放上参考答案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> numbers.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers[i] + numbers[j];</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i+<span class="number">1</span>, j+<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，虽然本题叫做 Two Sum II，但解法和 Two Sum 完全不同。</p><p><code>图解双指针解法的原理</code><br>在这道题中，我们要寻找的是符合条件的一对下标 (i, j)，它们需要满足的约束条件是：</p><ol><li>i,j 都是合法的下标</li><li>且i&lt;j</li></ol><p>而我们希望从中找到满足 A[i] + A[j] &#x3D;&#x3D; target 的下标 (i, j)。以 n &#x3D; 8为例，这时候全部的搜索空间是：</p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/6ee3750f6036a7a6249197e5b640bfc0564153ca1a61c1e35aad51f3a8f9dc5e.jpg" style="zoom:50%;" /><p>由于i,j的约束条件的限制，搜索空间是白色的倒三角部分。可以看到，搜索空间的大小是 O(n^2)数量级的。如果用暴力解法求解，一次只检查一个单元格，那么时间复杂度一定是 O(n^2)。要想得到 O(n)的解法，我们就需要能够一次排除多个单元格。那么我们来看看，本题的双指针解法是如何削减搜索空间的：</p><p>一开始，我们检查右上方单元格 (0, 7），即计算 A[0] + A[7] ，与 target 进行比较。如果不相等的话，则要么大于 target，要么小于 target。</p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/11af3da798c61eb69691db9ac28c74383b4c5f9586c39689e0529b423c669221.jpg" style="zoom:50%;" /><p>假设此时 A[0] + A[7] 小于 target。这时候，我们应该去找<code>和更大的两个数</code>。由于 A[7] 已经是最大的数了，其他的数跟 A[0] 相加，和只会更小。也就是说 A[0] + A[6] 、A[0] + A[5]、……、A[0] + A[1] 也都小于 target，这些都是不合要求的解，可以一次排除。这相当于 i&#x3D;0的情况全部被排除。对应用双指针解法的代码，就是 i++，对应于搜索空间，就是削减了一行的搜索空间，如下图所示。</p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/50d93bb2d2ce3e2985460586d4350e8205543965d9689632a20f5650dde3cb95.jpg" style="zoom:50%;" /><p>排除掉了搜索空间中的一行之后，我们再看剩余的搜索空间，仍然是倒三角形状。我们检查右上方的单元格 (1, 7)，计算 A[1] + A[7] 与 target 进行比较。</p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/43cd9bb40aceb37a12c9ed4fe04e2df905a3f2be7e28cbd15465bbe3a8034915.jpg" style="zoom:50%;" /><p>假设此时 A[0] + A[7] 大于 target。这时候，我们应该去找<code>和更小的两个数</code>。由于 A[1] 已经是当前搜索空间最小的数了，其他的数跟 A[7] 相加的话，和只会更大。也就是说 A[1] + A[7] 、A[2] + A[7]、……、A[6] + A[7] 也都大于 target，这些都是不合要求的解，可以一次排除。这相当于 j&#x3D;0 的情况全部被排除。对应用双指针解法的代码，就是 j++，对应于搜索空间，就是削减了一列的搜索空间，如下图所示。</p><p>可以看到，无论 A[i] + A[j] 的结果是大了还是小了，我们都可以排除掉一行或者一列的搜索空间。经过 n 步以后，就能排除所有的搜索空间，检查完所有的可能性。搜索空间的减小过程如下面动图所示：</p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/9ebb3ff74f0706c3c350b7fb91fea343e54750eb5b6ae6a4a3493421a019922a.gif" style="zoom:50%;" /><p>实际上还有几道题也是用到了这样的缩减搜索空间的思想：</p><ul><li><p>11.Container With Most Water</p></li><li><p>240.Search a 2D Matrix II</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树模板</title>
      <link href="/2022/04/20/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A8%A1%E6%9D%BF/"/>
      <url>/2022/04/20/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="二叉树模板"><a href="#二叉树模板" class="headerlink" title="二叉树模板"></a>二叉树模板</h3><p>二叉树算法的设计的总路线：明确一个节点要做的事情，然后剩下的事抛给框架。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// root 需要做什么？在这做。</span></span><br><span class="line">    <span class="comment">// 其他的不用 root 操心，抛给框架</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举两个简单的例子体会一下这个思路，热热身。</p><p><code>1. 如何把二叉树所有的节点中的值加一？</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">plusOne</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    root.val += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    plusOne(root.left);</span><br><span class="line">    plusOne(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>2. 如何判断两棵二叉树是否完全相同？</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">    <span class="comment">// 都为空的话，显然相同</span></span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 一个为空，一个非空，显然不同</span></span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">null</span> || root2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 两个都非空，但 val 不一样也不行</span></span><br><span class="line">    <span class="keyword">if</span> (root1.val != root2.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// root1 和 root2 该比的都比完了</span></span><br><span class="line">    <span class="keyword">return</span> isSameTree(root1.left, root2.left)</span><br><span class="line">        &amp;&amp; isSameTree(root1.right, root2.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助框架，上面这两个例子不难理解吧？如果可以理解，那么所有二叉树算法你都能解决。</p><p>二叉搜索树（Binary Search Tree，简称 BST）是一种很常用的的二叉树。它的定义是：一个二叉树中，任意节点的值要大于等于左子树所有节点的值，且要小于等于右边子树的所有节点的值。</p><p>如下就是一个符合定义的 BST：</p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/1600680568-gbNFQp-file_1600680568458.png" style="zoom: 67%;" /><p>下面实现 BST 的基础操作：判断 BST 的合法性、增、删、查。其中“删”和“判断合法性”略微复杂。</p><p><code>零、判断 BST 的合法性</code></p><p>这里是有坑的哦，我们按照刚才的思路，每个节点自己要做的事不就是比较自己和左右孩子吗？看起来应该这样写代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.val &lt;= root.left.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span> &amp;&amp; root.val &gt;= root.right.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left)</span><br><span class="line">        &amp;&amp; isValidBST(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个算法出现了错误，BST 的每个节点应该要小于右边子树的所有节点，下面这个二叉树显然不是 BST，但是我们的算法会把它判定为 BST。</p><p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/1600680568-AOVcUs-file_1600680568465.png"></p><p>出现错误，不要慌张，框架没有错，一定是某个细节问题没注意到。我们重新看一下 BST 的定义，root 需要做的不只是和左右子节点比较，而是要整个左子树和右子树所有节点比较。怎么办，鞭长莫及啊！</p><p>这种情况，我们可以使用辅助函数，增加函数参数列表，在参数中携带额外信息，请看正确的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root, TreeNode min, TreeNode max)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (min != <span class="literal">null</span> &amp;&amp; root.val &lt;= min.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (max != <span class="literal">null</span> &amp;&amp; root.val &gt;= max.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left, min, root) </span><br><span class="line">        &amp;&amp; isValidBST(root.right, root, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在-BST-中查找一个数是否存在"><a href="#在-BST-中查找一个数是否存在" class="headerlink" title="在 BST 中查找一个数是否存在"></a>在 BST 中查找一个数是否存在</h4><p>根据我们的指导思想，可以这样写代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isInBST</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.val == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isInBST(root.left, target)</span><br><span class="line">        || isInBST(root.right, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写完全正确，充分证明了你的框架性思维已经养成。现在你可以考虑一点细节问题了：如何充分利用信息，把 BST 这个“左小右大”的特性用上？</p><p>很简单，其实不需要递归地搜索两边，类似二分查找思想，根据 target 和 root.val 的大小比较，就能排除一边。我们把上面的思路稍稍改动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isInBST</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.val == target)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; target) </span><br><span class="line">        <span class="keyword">return</span> isInBST(root.right, target);</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; target)</span><br><span class="line">        <span class="keyword">return</span> isInBST(root.left, target);</span><br><span class="line">    <span class="comment">// root 该做的事做完了，顺带把框架也完成了，妙</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是，我们对原始框架进行改造，抽象出一套<code>针对 BST 的遍历框架：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">BST</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root.val == target)</span><br><span class="line">        <span class="comment">// 找到目标，做点什么</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; target) </span><br><span class="line">        BST(root.right, target);</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; target)</span><br><span class="line">        BST(root.left, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在-BST-中插入一个数"><a href="#在-BST-中插入一个数" class="headerlink" title="在 BST 中插入一个数"></a>在 BST 中插入一个数</h4><p>对数据结构的操作无非遍历 + 访问，遍历就是“找”，访问就是“改”。具体到这个问题，插入一个数，就是先找到插入位置，然后进行插入操作。</p><p>上一个问题，我们总结了 BST 中的遍历框架，就是“找”的问题。直接套框架，加上“改”的操作即可。一旦涉及“改”，函数就要返回 TreeNode 类型，并且对递归调用的返回值进行接收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">// 找到空位置插入新节点</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">    <span class="comment">// if (root.val == val)</span></span><br><span class="line">    <span class="comment">//     BST 中一般不会插入已存在元素</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; val) </span><br><span class="line">        root.right = insertIntoBST(root.right, val);</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; val) </span><br><span class="line">        root.left = insertIntoBST(root.left, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在-BST-中删除一个数"><a href="#在-BST-中删除一个数" class="headerlink" title="在 BST 中删除一个数"></a>在 BST 中删除一个数</h4><p>这个问题稍微复杂，不过你有框架指导，难不住你。跟插入操作类似，先“找”再“改”，先把框架写出来再说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">        <span class="comment">// 找到啦，进行删除</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; key) &#123;</span><br><span class="line">        root.left = deleteNode(root.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line">        root.right = deleteNode(root.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到目标节点了，比方说是节点 A，如何删除这个节点，这是难点。因为删除节点的同时不能破坏 BST 的性质。有三种情况，用图片来说明。</p><p>情况 1：A 恰好是末端节点，两个子节点都为空，那么它可以当场去世了。</p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/1600680568-eWmViP-file_1600680568466.png" style="zoom: 40%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>情况 2：A 只有一个非空子节点，那么它要让这个孩子接替自己的位置。</p><p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/1600680568-CYFeXO-file_1600680568471.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排除了情况 1 之后</span></span><br><span class="line"><span class="keyword">if</span> (root.left == <span class="literal">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line"><span class="keyword">if</span> (root.right == <span class="literal">null</span>) <span class="keyword">return</span> root.left;</span><br></pre></td></tr></table></figure><p>情况 3：A 有两个子节点，麻烦了，为了不破坏 BST 的性质，A 必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。我们以第二种方式讲解。</p><p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/1600680568-kbexkC-file_1600680568474.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 找到右子树的最小节点</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">minNode</span> <span class="operator">=</span> getMin(root.right);</span><br><span class="line">    <span class="comment">// 把 root 改成 minNode</span></span><br><span class="line">    root.val = minNode.val;</span><br><span class="line">    <span class="comment">// 转而去删除 minNode</span></span><br><span class="line">    root.right = deleteNode(root.right, minNode.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种情况分析完毕，填入框架，简化一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">        <span class="comment">// 这两个 if 把情况 1 和 2 都正确处理了</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">        <span class="keyword">if</span> (root.right == <span class="literal">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">        <span class="comment">// 处理情况 3</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">minNode</span> <span class="operator">=</span> getMin(root.right);</span><br><span class="line">        root.val = minNode.val;</span><br><span class="line">        root.right = deleteNode(root.right, minNode.val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; key) &#123;</span><br><span class="line">        root.left = deleteNode(root.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line">        root.right = deleteNode(root.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode <span class="title function_">getMin</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="comment">// BST 最左边的就是最小的</span></span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="literal">null</span>) node = node.left;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除操作就完成了。注意一下，这个删除操作并不完美，因为我们一般不会通过 root.val &#x3D; minNode.val 修改节点内部的值来交换节点，而是通过一系列略微复杂的链表操作交换 root 和 minNode 两个节点。因为具体应用中，val 域可能会很大，修改起来很耗时，而链表操作无非改一改指针，而不会去碰内部数据。</p><p>但这里忽略这个细节，旨在突出 BST 基本操作的共性，以及借助框架逐层细化问题的思维方式。</p><h4 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h4><p>通过这篇文章，你学会了如下几个技巧：</p><ol><li><p>二叉树算法设计的总路线：把当前节点要做的事做好，其他的交给递归框架，不用当前节点操心。</p></li><li><p>如果当前节点会对下面的子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。</p></li><li><p>在二叉树框架之上，扩展出一套 BST 遍历框架：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">BST</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root.val == target)</span><br><span class="line">        <span class="comment">// 找到目标，做点什么</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; target) </span><br><span class="line">        BST(root.right, target);</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; target)</span><br><span class="line">        BST(root.left, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>掌握了 BST 的基本操作。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针(链表)</title>
      <link href="/2022/04/20/%E5%8F%8C%E6%8C%87%E9%92%88(%E9%93%BE%E8%A1%A8)/"/>
      <url>/2022/04/20/%E5%8F%8C%E6%8C%87%E9%92%88(%E9%93%BE%E8%A1%A8)/</url>
      
        <content type="html"><![CDATA[<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>无法高效获取长度，无法根据偏移快速访问元素，是链表的两个劣势。然而面试的时候经常碰见诸如<strong>获取倒数第k个元素，获取中间位置的元素，判断链表是否存在环，判断环的长度等和长度与位置有关的问题</strong>。这些问题都可以通过灵活运用<strong>双指针</strong>来解决。</p><p><code>Tips：双指针并不是固定的公式，而是一种思维方式~</code></p><p>先来看”倒数第k个元素的问题”。设有两个指针 p 和 q，初始时均指向头结点。首先，先让 p 沿着 next 移动 k 次。此时，p 指向第 k+1个结点，q 指向头节点，两个指针的距离为 k 。然后，同时移动 p 和 q，直到 p 指向空，此时 q 即指向倒数第 k 个结点。可以参考下图来理解：</p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/8fc9ef022554d2a062db6a70d5199dbbb2a154ba1e64f0f697319bb0ef9ac680.png" style="zoom:80%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">kNode</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(k != <span class="number">0</span> &amp;&amp; kNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            kNode = kNode.next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(kNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            kNode = kNode.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取中间元素的问题。设有两个指针 fast 和 slow，初始时指向头节点。每次移动时，fast向后走两次，slow向后走一次，直到 fast 无法向后走两次。这使得在每轮移动之后，<strong>fast 和 slow 的距离就会增加一</strong>。设链表有 n 个元素，那么最多移动 n&#x2F;2 轮。<strong>当 n 为奇数时，slow 恰好指向中间结点，当 n 为 偶数时，slow 恰好指向中间两个结点的靠前一个</strong>(可以考虑下<strong>如何使其指向后一个结点呢？</strong>)。</p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/7984572cea859a3d569932934fe6580abf3f59221ec95911f662f1f19b6822aa.png" style="zoom:80%;" /><p>下述代码实现了 n 为<strong>偶数</strong>时慢指针指向<strong>靠后结点</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *p = head, *q = head;</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="literal">nullptr</span> &amp;&amp; q-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>是否存在环的问题。如果将尾结点的 next 指针指向其他任意一个结点，那么链表就存在了一个环。</p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/ea4aff71116d6c483b2b34519497d39d640435cb3ce12ea1b40dd453c45b59fd.png" style="zoom:80%;" /><p>上一部分中，总结快慢指针的特性 —— 每轮移动之后两者的距离会加一。下面会继续用该特性解决环的问题。<br>当一个链表有环时，快慢指针都会陷入环中进行无限次移动，然后变成了追及问题。想象一下在操场跑步的场景，只要一直跑下去，快的总会追上慢的。当两个指针都进入环后，每轮移动使得慢指针到快指针的距离增加一，同时快指针到慢指针的距离也减少一，只要一直移动下去，快指针总会追上慢指针。</p><p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/d1ac82780e5189d7d58406504c3b7b56c35165997bfbb4c325677af92ee2d483.gif"></p><p>根据上述表述得出，如果一个链表存在环，那么快慢指针必然会相遇。实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一个问题，如果存在环，如何判断环的长度呢？方法是，<code>快慢指针相遇后继续移动，直到第二次相遇。两次相遇间的移动次数即为环的长度。</code></p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/2b7a4130111600cf615b5584b3cc7f863d289a9a7d43b90147c79f51f68a5aa6-876-1.png" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/5c3f88cc6b312b7193a6e071cef93ec5eb3070005af23cad22a11e10ea0aca3e-876-2.png" style="zoom:33%;" />]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/2022/04/20/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2022/04/20/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/image-20220421171440664.png" style="zoom: 80%;" /><p>在一个范围内，查找一个数字，要求找到这个元素的开始位置和结束位置，这个范围内的数字都是单调递增的，即具有单调性质，因此可以使用二分来做。</p><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/1629777455-UMFPFX-file_1629777455526.png" style="zoom:80%;" /><p>两次二分，第一次二分查找第一个&gt;&#x3D;target&gt;&#x3D;target的位置，第二次二分查找最后一个&lt;&#x3D;target&lt;&#x3D;target的位置。查找成功则返回两个位置下标，否则返回[-1,-1]</p><h4 id="二分模板"><a href="#二分模板" class="headerlink" title="二分模板"></a>二分模板</h4><h5 id="模板1"><a href="#模板1" class="headerlink" title="模板1"></a>模板1</h5><p>当我们将区间l,r划分成[l,mid]和[mid + 1, r]时，其更新操作是r &#x3D; mid或者l &#x3D; mid + 1，计算mid时不需要加1，即mid &#x3D; (l + r)&#x2F;2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="模板2"><a href="#模板2" class="headerlink" title="模板2"></a>模板2</h5><p>当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r &#x3D; mid - 1或者l &#x3D; mid，此时为了防止死循环，计算mid时需要加1，即mid &#x3D; ( l + r + 1 ) &#x2F;2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> ( l + r + <span class="number">1</span> ) /<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>为什么两个二分模板mid取值不同？</code></p><p>对于第二个模板，当我们更新区间时，如果左边界l更新为l &#x3D; mid，此时mid的取值就应为mid &#x3D; (l + r + 1)&#x2F; 2。因为当右边界r &#x3D; l + 1时，此时mid &#x3D; (l + l + 1)&#x2F;2，下取整，mid仍为l，左边界再次更新为l &#x3D; mid &#x3D; l，相当于没有变化，while循环就会陷入死循环。因此，我们总结出来一个小技巧，当左边界要更新为l &#x3D; mid时，我们就令 mid &#x3D;(l + r + 1)&#x2F;2，上取整，此时就不会因为r取特殊值r &#x3D; l + 1而陷入死循环了。</p><p>而对于第一个模板，如果左边界ll更新为l &#x3D; mid + 1，是不会出现这样的困扰的。因此，大家可以熟记这两个二分模板，基本上可以解决99%以上的二分问题，再也不会被二分的边界取值所困扰了。</p><p><code>什么时候用模板1？什么时候用模板2？</code></p><p>假设初始时我们的二分区间为[l,r]，每次二分缩小区间时，如果左边界ll要更新为 l &#x3D; mid，此时我们就要使用模板2，让 mid &#x3D; (l + r + 1)&#x2F; 2，否则while会陷入死循环。如果左边界ll更新为l &#x3D; mid + 1,此时我们就使用模板1，让mid &#x3D; (l + r)&#x2F;2。因此，模板1和模板2本质上是根据代码来区分的，而不是应用场景。如果写完之后发现是l &#x3D; mid，那么在计算mid时需要加上1，否则如果写完之后发现是l &#x3D; mid + 1，那么在计算mid时不能加1。</p><p><code>为什么模板要取while( l &lt; r)，而不是while( l &lt;= r)？</code></p><p>本质上取l &lt; r 和 l &lt;&#x3D; r是没有任何区别的，只是习惯问题，如果取l &lt;&#x3D; r，只需要修改对应的更新区间即可。</p><p><code>while循环结束条件是l &gt;= r，但为什么二分结束时我们优先取r而不是l?</code></p><p>二分的while循环的结束条件是l &gt;&#x3D; r，所以在循环结束时l有可能会大于r，此时就可能导致越界，因此，基本上二分问题优先取r都不会翻车。</p><p><code>实现细节：</code></p><ul><li>二分查找时，首先要确定我们要查找的边界值，保证每次二分缩小区间时，边界值始终包含在内。</li><li>注意看下面的每张图，最后的答案就是红色箭头指出的位置，也是我们二分的边界值。如果不清楚每次二分时，区间是如何更新的，可以画出和下面类似的图，每次更新区间时，要保证边值始终包含在内，这样关于左右边界的更新就会一目了然。</li></ul><p><code>第一次查找起始位置:</code></p><ol><li>二分的范围，l &#x3D; 0， r &#x3D; nums.size() - 1，我们去二分查找&gt;&#x3D;target的最左边界。</li><li>当nums[mid] &gt;&#x3D; target时，往左半区域找，r &#x3D; mid。</li></ol><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/1629777618-TxbKzQ-file_1629777618424.png" style="zoom:80%;" /><ol start="3"><li>当nums[mid] &lt; target时， 往右半区域找，l &#x3D; mid + 1。</li></ol><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/1629777618-MlQEQA-file_1629777618427.png" style="zoom:80%;" /><ol start="4"><li>如果nums[r] !&#x3D; target，说明数组中不存在目标值 target，返回 [-1, -1]。否则我们就找到了第一个&gt;&#x3D;target的位置L</li></ol><p><code>第二次查找结束位置：</code></p><ol><li><p>二分的范围，l &#x3D; 0， r &#x3D; nums.size() - 1，我们去二分查找&lt;&#x3D;target的最右边界。</p></li><li><p>当nums[mid] &lt;&#x3D; target时，往右半区域找，l &#x3D; mid。</p></li></ol><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/1629777618-VJUqiS-file_1629777618429.png" style="zoom:80%;" /><ol start="3"><li>当nums[mid] &gt; target时， 往左半区域找，r &#x3D; mid - 1。</li></ol><img src="https://cdn.jsdelivr.net/gh/Prism-10297/picgoImg/img/1629777618-IxXaMK-file_1629777618431.png" style="zoom:80%;" /><ol start="4"><li>找到了最后一个&lt;&#x3D;target的位置R，返回区间[L,R]即可。</li></ol><p><code>时间复杂度分析：</code>两次二分查找的时间复杂度为 O(logn)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>; <span class="comment">//二分范围</span></span><br><span class="line">        <span class="keyword">while</span>( l &lt; r)        <span class="comment">//查找元素的开始位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r )/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( nums[r] != target) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;; <span class="comment">//查找失败</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> r;</span><br><span class="line">        l = <span class="number">0</span>; r = nums.length - <span class="number">1</span>;     <span class="comment">//二分范围</span></span><br><span class="line">        <span class="keyword">while</span>( l &lt; r)        <span class="comment">//查找元素的结束位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target ) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;L,r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快乘模板"><a href="#快乘模板" class="headerlink" title="快乘模板"></a>快乘模板</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">mul</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> k)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((k &amp; <span class="number">1</span>) == <span class="number">1</span>) ans += a;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a += a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
